// This file is auto-generated by @hey-api/openapi-ts

import type { Options } from '@hey-api/client-axios';
import { queryOptions, type UseMutationOptions, type DefaultError } from '@tanstack/react-query';
import type { PostAuthSignupData, PostAuthSignupResponse, PostAuthMeData, PostAuthMeResponse, PostAuthLogoutData, PostAuthAccessTokenData, PostAuthAccessTokenResponse, GetBooksData, PostBooksData, PostBooksResponse, DeleteBooksByIdData, DeleteBooksByIdResponse, GetBooksByIdData, PutBooksByIdData, PutBooksByIdResponse, GetAuthorsData, PostAuthorsData, PostAuthorsResponse, DeleteAuthorsByIdData, DeleteAuthorsByIdResponse, GetAuthorsByIdData, PutAuthorsByIdData, PutAuthorsByIdResponse } from './types.gen';
import type { AxiosError } from 'axios';
import { AuthenticationService, BooksService, AuthorsService, client } from './sdk.gen';

type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): QueryKey<TOptions>[0] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseURL: (options?.client ?? client).getConfig().baseURL } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return params;
};

export const postAuthSignupQueryKey = (options?: Options<PostAuthSignupData>) => [
    createQueryKey('postAuthSignup', options)
];

export const postAuthSignupOptions = (options?: Options<PostAuthSignupData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await AuthenticationService.postAuthSignup({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthSignupQueryKey(options)
    });
};

export const postAuthSignupMutation = (options?: Partial<Options<PostAuthSignupData>>) => {
    const mutationOptions: UseMutationOptions<PostAuthSignupResponse, AxiosError<DefaultError>, Options<PostAuthSignupData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await AuthenticationService.postAuthSignup({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postAuthMeQueryKey = (options?: Options<PostAuthMeData>) => [
    createQueryKey('postAuthMe', options)
];

export const postAuthMeOptions = (options?: Options<PostAuthMeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await AuthenticationService.postAuthMe({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthMeQueryKey(options)
    });
};

export const postAuthMeMutation = (options?: Partial<Options<PostAuthMeData>>) => {
    const mutationOptions: UseMutationOptions<PostAuthMeResponse, AxiosError<DefaultError>, Options<PostAuthMeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await AuthenticationService.postAuthMe({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postAuthLogoutQueryKey = (options?: Options<PostAuthLogoutData>) => [
    createQueryKey('postAuthLogout', options)
];

export const postAuthLogoutOptions = (options?: Options<PostAuthLogoutData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await AuthenticationService.postAuthLogout({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthLogoutQueryKey(options)
    });
};

export const postAuthLogoutMutation = (options?: Partial<Options<PostAuthLogoutData>>) => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<PostAuthLogoutData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await AuthenticationService.postAuthLogout({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postAuthAccessTokenQueryKey = (options?: Options<PostAuthAccessTokenData>) => [
    createQueryKey('postAuthAccessToken', options)
];

export const postAuthAccessTokenOptions = (options?: Options<PostAuthAccessTokenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await AuthenticationService.postAuthAccessToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthAccessTokenQueryKey(options)
    });
};

export const postAuthAccessTokenMutation = (options?: Partial<Options<PostAuthAccessTokenData>>) => {
    const mutationOptions: UseMutationOptions<PostAuthAccessTokenResponse, AxiosError<DefaultError>, Options<PostAuthAccessTokenData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await AuthenticationService.postAuthAccessToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBooksQueryKey = (options?: Options<GetBooksData>) => [
    createQueryKey('getBooks', options)
];

export const getBooksOptions = (options?: Options<GetBooksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await BooksService.getBooks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBooksQueryKey(options)
    });
};

export const postBooksQueryKey = (options?: Options<PostBooksData>) => [
    createQueryKey('postBooks', options)
];

export const postBooksOptions = (options?: Options<PostBooksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await BooksService.postBooks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postBooksQueryKey(options)
    });
};

export const postBooksMutation = (options?: Partial<Options<PostBooksData>>) => {
    const mutationOptions: UseMutationOptions<PostBooksResponse, AxiosError<DefaultError>, Options<PostBooksData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await BooksService.postBooks({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteBooksByIdMutation = (options?: Partial<Options<DeleteBooksByIdData>>) => {
    const mutationOptions: UseMutationOptions<DeleteBooksByIdResponse, AxiosError<DefaultError>, Options<DeleteBooksByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await BooksService.deleteBooksById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBooksByIdQueryKey = (options: Options<GetBooksByIdData>) => [
    createQueryKey('getBooksById', options)
];

export const getBooksByIdOptions = (options: Options<GetBooksByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await BooksService.getBooksById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBooksByIdQueryKey(options)
    });
};

export const putBooksByIdMutation = (options?: Partial<Options<PutBooksByIdData>>) => {
    const mutationOptions: UseMutationOptions<PutBooksByIdResponse, AxiosError<DefaultError>, Options<PutBooksByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await BooksService.putBooksById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAuthorsQueryKey = (options?: Options<GetAuthorsData>) => [
    createQueryKey('getAuthors', options)
];

export const getAuthorsOptions = (options?: Options<GetAuthorsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await AuthorsService.getAuthors({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAuthorsQueryKey(options)
    });
};

export const postAuthorsQueryKey = (options?: Options<PostAuthorsData>) => [
    createQueryKey('postAuthors', options)
];

export const postAuthorsOptions = (options?: Options<PostAuthorsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await AuthorsService.postAuthors({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthorsQueryKey(options)
    });
};

export const postAuthorsMutation = (options?: Partial<Options<PostAuthorsData>>) => {
    const mutationOptions: UseMutationOptions<PostAuthorsResponse, AxiosError<DefaultError>, Options<PostAuthorsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await AuthorsService.postAuthors({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteAuthorsByIdMutation = (options?: Partial<Options<DeleteAuthorsByIdData>>) => {
    const mutationOptions: UseMutationOptions<DeleteAuthorsByIdResponse, AxiosError<DefaultError>, Options<DeleteAuthorsByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await AuthorsService.deleteAuthorsById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAuthorsByIdQueryKey = (options: Options<GetAuthorsByIdData>) => [
    createQueryKey('getAuthorsById', options)
];

export const getAuthorsByIdOptions = (options: Options<GetAuthorsByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await AuthorsService.getAuthorsById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAuthorsByIdQueryKey(options)
    });
};

export const putAuthorsByIdMutation = (options?: Partial<Options<PutAuthorsByIdData>>) => {
    const mutationOptions: UseMutationOptions<PutAuthorsByIdResponse, AxiosError<DefaultError>, Options<PutAuthorsByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await AuthorsService.putAuthorsById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};
