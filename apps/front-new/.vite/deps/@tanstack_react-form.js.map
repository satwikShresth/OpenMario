{
  "version": 3,
  "sources": ["../../../../node_modules/.deno/@tanstack+form-core@1.14.0/node_modules/@tanstack/form-core/src/utils.ts", "../../../../node_modules/.deno/@tanstack+form-core@1.14.0/node_modules/@tanstack/form-core/src/standardSchemaValidator.ts", "../../../../node_modules/.deno/@tanstack+form-core@1.14.0/node_modules/@tanstack/form-core/src/metaHelper.ts", "../../../../node_modules/.deno/@tanstack+form-core@1.14.0/node_modules/@tanstack/form-core/src/FormApi.ts", "../../../../node_modules/.deno/@tanstack+form-core@1.14.0/node_modules/@tanstack/form-core/src/FieldApi.ts", "../../../../node_modules/.deno/@tanstack+form-core@1.14.0/node_modules/@tanstack/form-core/src/mergeForm.ts", "../../../../node_modules/.deno/@tanstack+form-core@1.14.0/node_modules/@tanstack/form-core/src/formOptions.ts", "../../../../node_modules/.deno/@tanstack+react-form@1.14.1/node_modules/@tanstack/react-form/src/useIsomorphicLayoutEffect.ts", "../../../../node_modules/.deno/@tanstack+react-form@1.14.1/node_modules/@tanstack/react-form/src/useField.tsx", "../../../../node_modules/.deno/@tanstack+react-form@1.14.1/node_modules/@tanstack/react-form/src/useForm.tsx", "../../../../node_modules/.deno/@tanstack+react-form@1.14.1/node_modules/@tanstack/react-form/src/useTransform.ts", "../../../../node_modules/.deno/@tanstack+react-form@1.14.1/node_modules/@tanstack/react-form/src/createFormHook.tsx"],
  "sourcesContent": ["import type { FieldValidators } from './FieldApi'\nimport type { FormValidators } from './FormApi'\nimport type {\n  GlobalFormValidationError,\n  ValidationCause,\n  ValidationError,\n  ValidationSource,\n} from './types'\n\nexport type UpdaterFn<TInput, TOutput = TInput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput = TInput> =\n  | TOutput\n  | UpdaterFn<TInput, TOutput>\n\n/**\n * @private\n */\nexport function functionalUpdate<TInput, TOutput = TInput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as UpdaterFn<TInput, TOutput>)(input)\n    : updater\n}\n\n/**\n * Get a value from an object using a path, including dot notation.\n * @private\n */\nexport function getBy(obj: any, path: any) {\n  const pathObj = makePathArray(path)\n  return pathObj.reduce((current: any, pathPart: any) => {\n    if (current === null) return null\n    if (typeof current !== 'undefined') {\n      return current[pathPart]\n    }\n    return undefined\n  }, obj)\n}\n\n/**\n * Set a value on an object using a path, including dot notation.\n * @private\n */\nexport function setBy(obj: any, _path: any, updater: Updater<any>) {\n  const path = makePathArray(_path)\n\n  function doSet(parent?: any): any {\n    if (!path.length) {\n      return functionalUpdate(updater, parent)\n    }\n\n    const key = path.shift()\n\n    if (\n      typeof key === 'string' ||\n      (typeof key === 'number' && !Array.isArray(parent))\n    ) {\n      if (typeof parent === 'object') {\n        if (parent === null) {\n          parent = {}\n        }\n        return {\n          ...parent,\n          [key]: doSet(parent[key]),\n        }\n      }\n      return {\n        [key]: doSet(),\n      }\n    }\n\n    if (Array.isArray(parent) && typeof key === 'number') {\n      const prefix = parent.slice(0, key)\n      return [\n        ...(prefix.length ? prefix : new Array(key)),\n        doSet(parent[key]),\n        ...parent.slice(key + 1),\n      ]\n    }\n    return [...new Array(key), doSet()]\n  }\n\n  return doSet(obj)\n}\n\n/**\n * Delete a field on an object using a path, including dot notation.\n * @private\n */\nexport function deleteBy(obj: any, _path: any) {\n  const path = makePathArray(_path)\n\n  function doDelete(parent: any): any {\n    if (!parent) return\n    if (path.length === 1) {\n      const finalPath = path[0]!\n      if (Array.isArray(parent) && typeof finalPath === 'number') {\n        return parent.filter((_, i) => i !== finalPath)\n      }\n      const { [finalPath]: remove, ...rest } = parent\n      return rest\n    }\n\n    const key = path.shift()\n\n    if (typeof key === 'string') {\n      if (typeof parent === 'object') {\n        return {\n          ...parent,\n          [key]: doDelete(parent[key]),\n        }\n      }\n    }\n\n    if (typeof key === 'number') {\n      if (Array.isArray(parent)) {\n        if (key >= parent.length) {\n          return parent\n        }\n        const prefix = parent.slice(0, key)\n        return [\n          ...(prefix.length ? prefix : new Array(key)),\n          doDelete(parent[key]),\n          ...parent.slice(key + 1),\n        ]\n      }\n    }\n\n    throw new Error('It seems we have created an infinite loop in deleteBy. ')\n  }\n\n  return doDelete(obj)\n}\n\nconst reLineOfOnlyDigits = /^(\\d+)$/gm\n// the second dot must be in a lookahead or the engine\n// will skip subsequent numbers (like foo.0.1.)\nconst reDigitsBetweenDots = /\\.(\\d+)(?=\\.)/gm\nconst reStartWithDigitThenDot = /^(\\d+)\\./gm\nconst reDotWithDigitsToEnd = /\\.(\\d+$)/gm\nconst reMultipleDots = /\\.{2,}/gm\n\nconst intPrefix = '__int__'\nconst intReplace = `${intPrefix}$1`\n\n/**\n * @private\n */\nexport function makePathArray(str: string | Array<string | number>) {\n  if (Array.isArray(str)) {\n    return [...str]\n  }\n\n  if (typeof str !== 'string') {\n    throw new Error('Path must be a string.')\n  }\n\n  return (\n    str\n      // Leading `[` may lead to wrong parsing down the line\n      // (Example: '[0][1]' should be '0.1', not '.0.1')\n      .replace(/(^\\[)|]/gm, '')\n      .replace(/\\[/g, '.')\n      .replace(reLineOfOnlyDigits, intReplace)\n      .replace(reDigitsBetweenDots, `.${intReplace}.`)\n      .replace(reStartWithDigitThenDot, `${intReplace}.`)\n      .replace(reDotWithDigitsToEnd, `.${intReplace}`)\n      .replace(reMultipleDots, '.')\n      .split('.')\n      .map((d) => {\n        if (d.indexOf(intPrefix) === 0) {\n          return parseInt(d.substring(intPrefix.length), 10)\n        }\n        return d\n      })\n  )\n}\n\n/**\n * @private\n */\nexport function isNonEmptyArray(obj: any) {\n  return !(Array.isArray(obj) && obj.length === 0)\n}\n\ninterface AsyncValidatorArrayPartialOptions<T> {\n  validators?: T\n  asyncDebounceMs?: number\n}\n\n/**\n * @private\n */\nexport interface AsyncValidator<T> {\n  cause: ValidationCause\n  validate: T\n  debounceMs: number\n}\n\n/**\n * @private\n */\nexport function getAsyncValidatorArray<T>(\n  cause: ValidationCause,\n  options: AsyncValidatorArrayPartialOptions<T>,\n): T extends FieldValidators<any, any, any, any, any, any, any, any, any, any>\n  ? Array<\n      AsyncValidator<T['onChangeAsync'] | T['onBlurAsync'] | T['onSubmitAsync']>\n    >\n  : T extends FormValidators<any, any, any, any, any, any, any, any>\n    ? Array<\n        AsyncValidator<\n          T['onChangeAsync'] | T['onBlurAsync'] | T['onSubmitAsync']\n        >\n      >\n    : never {\n  const { asyncDebounceMs } = options\n  const {\n    onChangeAsync,\n    onBlurAsync,\n    onSubmitAsync,\n    onBlurAsyncDebounceMs,\n    onChangeAsyncDebounceMs,\n  } = (options.validators || {}) as\n    | FieldValidators<any, any, any, any, any, any, any, any, any, any>\n    | FormValidators<any, any, any, any, any, any, any, any>\n\n  const defaultDebounceMs = asyncDebounceMs ?? 0\n\n  const changeValidator = {\n    cause: 'change',\n    validate: onChangeAsync,\n    debounceMs: onChangeAsyncDebounceMs ?? defaultDebounceMs,\n  } as const\n\n  const blurValidator = {\n    cause: 'blur',\n    validate: onBlurAsync,\n    debounceMs: onBlurAsyncDebounceMs ?? defaultDebounceMs,\n  } as const\n\n  const submitValidator = {\n    cause: 'submit',\n    validate: onSubmitAsync,\n    debounceMs: 0,\n  } as const\n\n  const noopValidator = (\n    validator:\n      | typeof changeValidator\n      | typeof blurValidator\n      | typeof submitValidator,\n  ) => ({ ...validator, debounceMs: 0 }) as const\n\n  switch (cause) {\n    case 'submit':\n      return [\n        noopValidator(changeValidator),\n        noopValidator(blurValidator),\n        submitValidator,\n      ] as never\n    case 'blur':\n      return [blurValidator] as never\n    case 'change':\n      return [changeValidator] as never\n    case 'server':\n    default:\n      return [] as never\n  }\n}\n\ninterface SyncValidatorArrayPartialOptions<T> {\n  validators?: T\n}\n\n/**\n * @private\n */\nexport interface SyncValidator<T> {\n  cause: ValidationCause\n  validate: T\n}\n\n/**\n * @private\n */\nexport function getSyncValidatorArray<T>(\n  cause: ValidationCause,\n  options: SyncValidatorArrayPartialOptions<T>,\n): T extends FieldValidators<any, any, any, any, any, any, any, any, any, any>\n  ? Array<\n      SyncValidator<T['onChange'] | T['onBlur'] | T['onSubmit'] | T['onMount']>\n    >\n  : T extends FormValidators<any, any, any, any, any, any, any, any>\n    ? Array<\n        SyncValidator<\n          T['onChange'] | T['onBlur'] | T['onSubmit'] | T['onMount']\n        >\n      >\n    : never {\n  const { onChange, onBlur, onSubmit, onMount } = (options.validators || {}) as\n    | FieldValidators<any, any, any, any, any, any, any, any, any, any>\n    | FormValidators<any, any, any, any, any, any, any, any>\n\n  const changeValidator = { cause: 'change', validate: onChange } as const\n  const blurValidator = { cause: 'blur', validate: onBlur } as const\n  const submitValidator = { cause: 'submit', validate: onSubmit } as const\n  const mountValidator = { cause: 'mount', validate: onMount } as const\n\n  // Allows us to clear onServer errors\n  const serverValidator = {\n    cause: 'server',\n    validate: () => undefined,\n  } as const\n\n  switch (cause) {\n    case 'mount':\n      return [mountValidator] as never\n    case 'submit':\n      return [\n        changeValidator,\n        blurValidator,\n        submitValidator,\n        serverValidator,\n      ] as never\n    case 'server':\n      return [serverValidator] as never\n    case 'blur':\n      return [blurValidator, serverValidator] as never\n    case 'change':\n    default:\n      return [changeValidator, serverValidator] as never\n  }\n}\n\nexport const isGlobalFormValidationError = (\n  error: unknown,\n): error is GlobalFormValidationError<unknown> => {\n  return !!error && typeof error === 'object' && 'fields' in error\n}\n\nexport function evaluate<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size) return false\n    for (const [k, v] of objA) {\n      if (!objB.has(k) || !Object.is(v, objB.get(k))) return false\n    }\n    return true\n  }\n\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size) return false\n    for (const v of objA) {\n      if (!objB.has(v)) return false\n    }\n    return true\n  }\n\n  const keysA = Object.keys(objA)\n  const keysB = Object.keys(objB)\n\n  if (keysA.length !== keysB.length) {\n    return false\n  }\n\n  for (const key of keysA) {\n    // performs recursive search down the object tree\n\n    if (\n      !keysB.includes(key) ||\n      !evaluate(objA[key as keyof T], objB[key as keyof T])\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Determines the logic for determining the error source and value to set on the field meta within the form level sync/async validation.\n * @private\n */\nexport const determineFormLevelErrorSourceAndValue = ({\n  newFormValidatorError,\n  isPreviousErrorFromFormValidator,\n  previousErrorValue,\n}: {\n  newFormValidatorError: ValidationError\n  isPreviousErrorFromFormValidator: boolean\n  previousErrorValue: ValidationError\n}): {\n  newErrorValue: ValidationError\n  newSource: ValidationSource | undefined\n} => {\n  // All falsy values are not considered errors\n  if (newFormValidatorError) {\n    return { newErrorValue: newFormValidatorError, newSource: 'form' }\n  }\n\n  // Clears form level error since it's now stale\n  if (isPreviousErrorFromFormValidator) {\n    return { newErrorValue: undefined, newSource: undefined }\n  }\n\n  // At this point, we have a preivous error which must have been set by the field validator, keep as is\n  if (previousErrorValue) {\n    return { newErrorValue: previousErrorValue, newSource: 'field' }\n  }\n\n  // No new or previous error, clear the error\n  return { newErrorValue: undefined, newSource: undefined }\n}\n\n/**\n * Determines the logic for determining the error source and value to set on the field meta within the field level sync/async validation.\n * @private\n */\nexport const determineFieldLevelErrorSourceAndValue = ({\n  formLevelError,\n  fieldLevelError,\n}: {\n  formLevelError: ValidationError\n  fieldLevelError: ValidationError\n}): {\n  newErrorValue: ValidationError\n  newSource: ValidationSource | undefined\n} => {\n  // At field level, we prioritize the field level error\n  if (fieldLevelError) {\n    return { newErrorValue: fieldLevelError, newSource: 'field' }\n  }\n\n  // If there is no field level error, and there is a form level error, we set the form level error\n  if (formLevelError) {\n    return { newErrorValue: formLevelError, newSource: 'form' }\n  }\n\n  return { newErrorValue: undefined, newSource: undefined }\n}\n", "import type { ValidationSource } from './types'\n\nexport type TStandardSchemaValidatorValue<\n  TData,\n  TSource extends ValidationSource = ValidationSource,\n> = {\n  value: TData\n  validationSource: TSource\n}\n\nexport type TStandardSchemaValidatorIssue<\n  TSource extends ValidationSource = ValidationSource,\n> = TSource extends 'form'\n  ? {\n      form: Record<string, StandardSchemaV1Issue[]>\n      fields: Record<string, StandardSchemaV1Issue[]>\n    }\n  : TSource extends 'field'\n    ? StandardSchemaV1Issue[]\n    : never\n\nfunction prefixSchemaToErrors(issues: readonly StandardSchemaV1Issue[]) {\n  const schema = new Map<string, StandardSchemaV1Issue[]>()\n\n  for (const issue of issues) {\n    const path = [...(issue.path ?? [])]\n      .map((segment) => {\n        const normalizedSegment =\n          typeof segment === 'object' ? segment.key : segment\n        return typeof normalizedSegment === 'number'\n          ? `[${normalizedSegment}]`\n          : normalizedSegment\n      })\n      .join('.')\n      .replace(/\\.\\[/g, '[')\n\n    schema.set(path, (schema.get(path) ?? []).concat(issue))\n  }\n\n  return Object.fromEntries(schema)\n}\n\nconst transformFormIssues = <TSource extends ValidationSource>(\n  issues: readonly StandardSchemaV1Issue[],\n): TStandardSchemaValidatorIssue<TSource> => {\n  const schemaErrors = prefixSchemaToErrors(issues)\n  return {\n    form: schemaErrors,\n    fields: schemaErrors,\n  } as TStandardSchemaValidatorIssue<TSource>\n}\n\nexport const standardSchemaValidators = {\n  validate<TSource extends ValidationSource = ValidationSource>(\n    {\n      value,\n      validationSource,\n    }: TStandardSchemaValidatorValue<unknown, TSource>,\n    schema: StandardSchemaV1,\n  ): TStandardSchemaValidatorIssue<TSource> | undefined {\n    const result = schema['~standard'].validate(value)\n\n    if (result instanceof Promise) {\n      throw new Error('async function passed to sync validator')\n    }\n\n    if (!result.issues) return\n\n    if (validationSource === 'field')\n      return result.issues as TStandardSchemaValidatorIssue<TSource>\n    return transformFormIssues<TSource>(result.issues)\n  },\n  async validateAsync<TSource extends ValidationSource>(\n    {\n      value,\n      validationSource,\n    }: TStandardSchemaValidatorValue<unknown, TSource>,\n    schema: StandardSchemaV1,\n  ): Promise<TStandardSchemaValidatorIssue<TSource> | undefined> {\n    const result = await schema['~standard'].validate(value)\n\n    if (!result.issues) return\n\n    if (validationSource === 'field')\n      return result.issues as TStandardSchemaValidatorIssue<TSource>\n    return transformFormIssues<TSource>(result.issues)\n  },\n}\n\nexport const isStandardSchemaValidator = (\n  validator: unknown,\n): validator is StandardSchemaV1 =>\n  !!validator && '~standard' in (validator as object)\n\n/**\n * The Standard Schema interface.\n */\nexport type StandardSchemaV1<Input = unknown, Output = Input> = {\n  /**\n   * The Standard Schema properties.\n   */\n  readonly '~standard': StandardSchemaV1Props<Input, Output>\n}\n\n/**\n * The Standard Schema properties interface.\n */\ninterface StandardSchemaV1Props<Input = unknown, Output = Input> {\n  /**\n   * The version number of the standard.\n   */\n  readonly version: 1\n  /**\n   * The vendor name of the schema library.\n   */\n  readonly vendor: string\n  /**\n   * Validates unknown input values.\n   */\n  readonly validate: (\n    value: unknown,\n  ) => StandardSchemaV1Result<Output> | Promise<StandardSchemaV1Result<Output>>\n  /**\n   * Inferred types associated with the schema.\n   */\n  readonly types?: StandardSchemaV1Types<Input, Output> | undefined\n}\n/**\n * The result interface of the validate function.\n */\ntype StandardSchemaV1Result<Output> =\n  | StandardSchemaV1SuccessResult<Output>\n  | StandardSchemaV1FailureResult\n/**\n * The result interface if validation succeeds.\n */\ninterface StandardSchemaV1SuccessResult<Output> {\n  /**\n   * The typed output value.\n   */\n  readonly value: Output\n  /**\n   * The non-existent issues.\n   */\n  readonly issues?: undefined\n}\n/**\n * The result interface if validation fails.\n */\ninterface StandardSchemaV1FailureResult {\n  /**\n   * The issues of failed validation.\n   */\n  readonly issues: ReadonlyArray<StandardSchemaV1Issue>\n}\n/**\n * The issue interface of the failure output.\n */\nexport interface StandardSchemaV1Issue {\n  /**\n   * The error message of the issue.\n   */\n  readonly message: string\n  /**\n   * The path of the issue, if any.\n   */\n  readonly path?:\n    | ReadonlyArray<PropertyKey | StandardSchemaV1PathSegment>\n    | undefined\n}\n/**\n * The path segment interface of the issue.\n */\ninterface StandardSchemaV1PathSegment {\n  /**\n   * The key representing a path segment.\n   */\n  readonly key: PropertyKey\n}\n/**\n * The Standard Schema types interface.\n */\ninterface StandardSchemaV1Types<Input = unknown, Output = Input> {\n  /**\n   * The input type of the schema.\n   */\n  readonly input: Input\n  /**\n   * The output type of the schema.\n   */\n  readonly output: Output\n}\n", "import type {\n  FormApi,\n  FormAsyncValidateOrFn,\n  FormValidateOrFn,\n} from './FormApi'\nimport type { AnyFieldMeta } from './FieldApi'\nimport type { DeepKeys } from './util-types'\n\ntype ArrayFieldMode = 'insert' | 'remove' | 'swap' | 'move'\n\nexport const defaultFieldMeta: AnyFieldMeta = {\n  isValidating: false,\n  isTouched: false,\n  isBlurred: false,\n  isDirty: false,\n  isPristine: true,\n  isValid: true,\n  isDefaultValue: true,\n  errors: [],\n  errorMap: {},\n  errorSourceMap: {},\n}\n\nexport function metaHelper<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta,\n>(\n  formApi: FormApi<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnServer,\n    TSubmitMeta\n  >,\n) {\n  function handleArrayFieldMetaShift(\n    field: DeepKeys<TFormData>,\n    index: number,\n    mode: ArrayFieldMode,\n    secondIndex?: number,\n  ) {\n    const affectedFields = getAffectedFields(field, index, mode, secondIndex)\n\n    const handlers = {\n      insert: () => handleInsertMode(affectedFields, field, index),\n      remove: () => handleRemoveMode(affectedFields),\n      swap: () =>\n        secondIndex !== undefined &&\n        handleSwapMode(affectedFields, field, index, secondIndex),\n      move: () =>\n        secondIndex !== undefined &&\n        handleMoveMode(affectedFields, field, index, secondIndex),\n    }\n\n    handlers[mode]()\n  }\n\n  function getFieldPath(field: DeepKeys<TFormData>, index: number): string {\n    return `${field}[${index}]`\n  }\n\n  function getAffectedFields(\n    field: DeepKeys<TFormData>,\n    index: number,\n    mode: ArrayFieldMode,\n    secondIndex?: number,\n  ): DeepKeys<TFormData>[] {\n    const affectedFieldKeys = [getFieldPath(field, index)]\n\n    if (mode === 'swap') {\n      affectedFieldKeys.push(getFieldPath(field, secondIndex!))\n    } else if (mode === 'move') {\n      const [startIndex, endIndex] = [\n        Math.min(index, secondIndex!),\n        Math.max(index, secondIndex!),\n      ]\n      for (let i = startIndex; i <= endIndex; i++) {\n        affectedFieldKeys.push(getFieldPath(field, i))\n      }\n    } else {\n      const currentValue = formApi.getFieldValue(field)\n      const fieldItems = Array.isArray(currentValue)\n        ? (currentValue as Array<unknown>).length\n        : 0\n      for (let i = index + 1; i < fieldItems; i++) {\n        affectedFieldKeys.push(getFieldPath(field, i))\n      }\n    }\n\n    return Object.keys(formApi.fieldInfo).filter((fieldKey) =>\n      affectedFieldKeys.some((key) => fieldKey.startsWith(key)),\n    ) as DeepKeys<TFormData>[]\n  }\n\n  function updateIndex(\n    fieldKey: string,\n    direction: 'up' | 'down',\n  ): DeepKeys<TFormData> {\n    return fieldKey.replace(/\\[(\\d+)\\]/, (_, num) => {\n      const currIndex = parseInt(num, 10)\n      const newIndex =\n        direction === 'up' ? currIndex + 1 : Math.max(0, currIndex - 1)\n      return `[${newIndex}]`\n    }) as DeepKeys<TFormData>\n  }\n\n  function shiftMeta(fields: DeepKeys<TFormData>[], direction: 'up' | 'down') {\n    const sortedFields = direction === 'up' ? fields : [...fields].reverse()\n\n    sortedFields.forEach((fieldKey) => {\n      const nextFieldKey = updateIndex(fieldKey.toString(), direction)\n      const nextFieldMeta = formApi.getFieldMeta(nextFieldKey)\n      if (nextFieldMeta) {\n        formApi.setFieldMeta(fieldKey, nextFieldMeta)\n      } else {\n        formApi.setFieldMeta(fieldKey, getEmptyFieldMeta())\n      }\n    })\n  }\n\n  const getEmptyFieldMeta = (): AnyFieldMeta => defaultFieldMeta\n\n  const handleInsertMode = (\n    fields: DeepKeys<TFormData>[],\n    field: DeepKeys<TFormData>,\n    insertIndex: number,\n  ) => {\n    shiftMeta(fields, 'down')\n\n    fields.forEach((fieldKey) => {\n      if (fieldKey.toString().startsWith(getFieldPath(field, insertIndex))) {\n        formApi.setFieldMeta(fieldKey, getEmptyFieldMeta())\n      }\n    })\n  }\n\n  const handleRemoveMode = (fields: DeepKeys<TFormData>[]) => {\n    shiftMeta(fields, 'up')\n  }\n\n  const handleMoveMode = (\n    fields: DeepKeys<TFormData>[],\n    field: DeepKeys<TFormData>,\n    fromIndex: number,\n    toIndex: number,\n  ) => {\n    // Store the original field meta that will be reapplied at the destination index\n    const fromFields = new Map(\n      Object.keys(formApi.fieldInfo)\n        .filter((fieldKey) =>\n          fieldKey.startsWith(getFieldPath(field, fromIndex)),\n        )\n        .map((fieldKey) => [\n          fieldKey as DeepKeys<TFormData>,\n          formApi.getFieldMeta(fieldKey as DeepKeys<TFormData>),\n        ]),\n    )\n\n    shiftMeta(fields, fromIndex < toIndex ? 'up' : 'down')\n\n    // Reapply the stored field meta at the destination index\n    Object.keys(formApi.fieldInfo)\n      .filter((fieldKey) => fieldKey.startsWith(getFieldPath(field, toIndex)))\n      .forEach((fieldKey) => {\n        const fromKey = fieldKey.replace(\n          getFieldPath(field, toIndex),\n          getFieldPath(field, fromIndex),\n        ) as DeepKeys<TFormData>\n\n        const fromMeta = fromFields.get(fromKey)\n        if (fromMeta) {\n          formApi.setFieldMeta(fieldKey as DeepKeys<TFormData>, fromMeta)\n        }\n      })\n  }\n\n  const handleSwapMode = (\n    fields: DeepKeys<TFormData>[],\n    field: DeepKeys<TFormData>,\n    index: number,\n    secondIndex: number,\n  ) => {\n    fields.forEach((fieldKey) => {\n      if (!fieldKey.toString().startsWith(getFieldPath(field, index))) return\n\n      const swappedKey = fieldKey\n        .toString()\n        .replace(\n          getFieldPath(field, index),\n          getFieldPath(field, secondIndex),\n        ) as DeepKeys<TFormData>\n\n      const [meta1, meta2] = [\n        formApi.getFieldMeta(fieldKey),\n        formApi.getFieldMeta(swappedKey),\n      ]\n\n      if (meta1) formApi.setFieldMeta(swappedKey, meta1)\n      if (meta2) formApi.setFieldMeta(fieldKey, meta2)\n    })\n  }\n\n  return { handleArrayFieldMetaShift }\n}\n", "import { Derived, Store, batch } from '@tanstack/store'\nimport {\n  deleteBy,\n  determineFormLevelErrorSourceAndValue,\n  evaluate,\n  functionalUpdate,\n  getAsyncValidatorArray,\n  getBy,\n  getSyncValidatorArray,\n  isGlobalFormValidationError,\n  isNonEmptyArray,\n  setBy,\n} from './utils'\n\nimport {\n  isStandardSchemaValidator,\n  standardSchemaValidators,\n} from './standardSchemaValidator'\nimport { defaultFieldMeta, metaHelper } from './metaHelper'\nimport type {\n  StandardSchemaV1,\n  StandardSchemaV1Issue,\n  TStandardSchemaValidatorValue,\n} from './standardSchemaValidator'\nimport type {\n  AnyFieldApi,\n  AnyFieldMeta,\n  AnyFieldMetaBase,\n  FieldApi,\n} from './FieldApi'\nimport type {\n  ExtractGlobalFormError,\n  FormValidationError,\n  FormValidationErrorMap,\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationErrorMapKeys,\n} from './types'\nimport type { DeepKeys, DeepKeysOfType, DeepValue } from './util-types'\nimport type { Updater } from './utils'\n\n/**\n * @private\n */\n// TODO: Add the `Unwrap` type to the errors\ntype FormErrorMapFromValidator<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = Partial<\n  Record<\n    DeepKeys<TFormData>,\n    ValidationErrorMap<\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync\n    >\n  >\n>\n\nexport type FormValidateFn<TFormData> = (props: {\n  value: TFormData\n  formApi: FormApi<\n    TFormData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => unknown\n\n/**\n * @private\n */\nexport type FormValidateOrFn<TFormData> =\n  | FormValidateFn<TFormData>\n  | StandardSchemaV1<TFormData, unknown>\n\nexport type UnwrapFormValidateOrFn<\n  TValidateOrFn extends undefined | FormValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateFn<any>]\n  ? ExtractGlobalFormError<ReturnType<TValidateOrFn>>\n  : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n    ? Record<string, StandardSchemaV1Issue[]>\n    : undefined\n\n/**\n * @private\n */\nexport type FormValidateAsyncFn<TFormData> = (props: {\n  value: TFormData\n  formApi: FormApi<\n    TFormData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n  signal: AbortSignal\n}) => unknown | Promise<unknown>\n\nexport type FormValidator<TFormData, TType, TFn = unknown> = {\n  validate(options: { value: TType }, fn: TFn): ValidationError\n  validateAsync(\n    options: { value: TType },\n    fn: TFn,\n  ): Promise<FormValidationError<TFormData>>\n}\n\ntype ValidationPromiseResult<TFormData> =\n  | {\n      fieldErrors: Partial<Record<DeepKeys<TFormData>, ValidationError>>\n      errorMapKey: ValidationErrorMapKeys\n    }\n  | undefined\n\n/**\n * @private\n */\nexport type FormAsyncValidateOrFn<TFormData> =\n  | FormValidateAsyncFn<TFormData>\n  | StandardSchemaV1<TFormData, unknown>\n\nexport type UnwrapFormAsyncValidateOrFn<\n  TValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateAsyncFn<any>]\n  ? ExtractGlobalFormError<Awaited<ReturnType<TValidateOrFn>>>\n  : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n    ? Record<string, StandardSchemaV1Issue[]>\n    : undefined\n\nexport interface FormValidators<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n> {\n  /**\n   * Optional function that fires as soon as the component mounts.\n   */\n  onMount?: TOnMount\n  /**\n   * Optional function that checks the validity of your data whenever a value changes\n   */\n  onChange?: TOnChange\n  /**\n   * Optional onChange asynchronous counterpart to onChange. Useful for more complex validation logic that might involve server requests.\n   */\n  onChangeAsync?: TOnChangeAsync\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * Optional function that validates the form data when a field loses focus, returns a `FormValidationError`\n   */\n  onBlur?: TOnBlur\n  /**\n   * Optional onBlur asynchronous validation method for when a field loses focus returns a ` FormValidationError` or a promise of `Promise<FormValidationError>`\n   */\n  onBlurAsync?: TOnBlurAsync\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onBlurAsyncDebounceMs?: number\n  onSubmit?: TOnSubmit\n  onSubmitAsync?: TOnSubmitAsync\n}\n\n/**\n * @private\n */\nexport interface FormTransform<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta = never,\n> {\n  fn: (\n    formBase: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) => FormApi<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnServer,\n    TSubmitMeta\n  >\n  deps: unknown[]\n}\n\nexport interface FormListeners<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta = never,\n> {\n  onChange?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    fieldApi: AnyFieldApi\n  }) => void\n  onChangeDebounceMs?: number\n\n  onBlur?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    fieldApi: AnyFieldApi\n  }) => void\n  onBlurDebounceMs?: number\n\n  onMount?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n  }) => void\n\n  onSubmit?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n  }) => void\n}\n\n/**\n * An object representing the options for a form.\n */\nexport interface FormOptions<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TSubmitMeta = never,\n> {\n  /**\n   * Set initial values for your form.\n   */\n  defaultValues?: TFormData\n  /**\n   * The default state for the form.\n   */\n  defaultState?: Partial<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer\n    >\n  >\n  /**\n   * If true, always run async validation, even when sync validation has produced an error. Defaults to undefined.\n   */\n  asyncAlways?: boolean\n  /**\n   * Optional time in milliseconds if you want to introduce a delay before firing off an async action.\n   */\n  asyncDebounceMs?: number\n  /**\n   * If true, allows the form to be submitted in an invalid state i.e. canSubmit will remain true regardless of validation errors. Defaults to undefined.\n   */\n  canSubmitWhenInvalid?: boolean\n  /**\n   * A list of validators to pass to the form\n   */\n  validators?: FormValidators<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync\n  >\n\n  /**\n   * onSubmitMeta, the data passed from the handleSubmit handler, to the onSubmit function props\n   */\n  onSubmitMeta?: TSubmitMeta\n\n  /**\n   * form level listeners\n   */\n  listeners?: FormListeners<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnServer,\n    TSubmitMeta\n  >\n\n  /**\n   * A function to be called when the form is submitted, what should happen once the user submits a valid form returns `any` or a promise `Promise<any>`\n   */\n  onSubmit?: (props: {\n    value: TFormData\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => any | Promise<any>\n  /**\n   * Specify an action for scenarios where the user tries to submit an invalid form.\n   */\n  onSubmitInvalid?: (props: {\n    value: TFormData\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n  }) => void\n  transform?: FormTransform<\n    NoInfer<TFormData>,\n    NoInfer<TOnMount>,\n    NoInfer<TOnChange>,\n    NoInfer<TOnChangeAsync>,\n    NoInfer<TOnBlur>,\n    NoInfer<TOnBlurAsync>,\n    NoInfer<TOnSubmit>,\n    NoInfer<TOnSubmitAsync>,\n    NoInfer<TOnServer>,\n    NoInfer<TSubmitMeta>\n  >\n}\n\n/**\n * An object representing the validation metadata for a field. Not intended for public usage.\n */\nexport type ValidationMeta = {\n  /**\n   * An abort controller stored in memory to cancel previous async validation attempts.\n   */\n  lastAbortController: AbortController\n}\n\n/**\n * An object representing the field information for a specific field within the form.\n */\nexport type FieldInfo<TFormData> = {\n  /**\n   * An instance of the FieldAPI.\n   */\n  instance: FieldApi<\n    TFormData,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > | null\n  /**\n   * A record of field validation internal handling.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n}\n\n/**\n * An object representing the current state of the form.\n */\nexport type BaseFormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = {\n  /**\n   * The current values of the form fields.\n   */\n  values: TFormData\n  /**\n   * The error map for the form itself.\n   */\n  errorMap: ValidationErrorMap<\n    UnwrapFormValidateOrFn<TOnMount>,\n    UnwrapFormValidateOrFn<TOnChange>,\n    UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n    UnwrapFormValidateOrFn<TOnBlur>,\n    UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n    UnwrapFormValidateOrFn<TOnSubmit>,\n    UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n    UnwrapFormAsyncValidateOrFn<TOnServer>\n  >\n  /**\n   * An internal mechanism used for keeping track of validation logic in a form.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n  /**\n   * A record of field metadata for each field in the form, not including the derived properties, like `errors` and such\n   */\n  fieldMetaBase: Record<DeepKeys<TFormData>, AnyFieldMetaBase>\n  /**\n   * A boolean indicating if the form is currently in the process of being submitted after `handleSubmit` is called.\n   *\n   * Goes back to `false` when submission completes for one of the following reasons:\n   * - the validation step returned errors.\n   * - the `onSubmit` function has completed.\n   *\n   * Note: if you're running async operations in your `onSubmit` function make sure to await them to ensure `isSubmitting` is set to `false` only when the async operation completes.\n   *\n   * This is useful for displaying loading indicators or disabling form inputs during submission.\n   *\n   */\n  isSubmitting: boolean\n  /**\n   * A boolean indicating if the `onSubmit` function has completed successfully.\n   *\n   * Goes back to `false` at each new submission attempt.\n   *\n   * Note: you can use isSubmitting to check if the form is currently submitting.\n   */\n  isSubmitted: boolean\n  /**\n   * A boolean indicating if the form or any of its fields are currently validating.\n   */\n  isValidating: boolean\n  /**\n   * A counter for tracking the number of submission attempts.\n   */\n  submissionAttempts: number\n  /**\n   * A boolean indicating if the last submission was successful.\n   */\n  isSubmitSuccessful: boolean\n  /**\n   * @private, used to force a re-evaluation of the form state when options change\n   */\n  _force_re_eval?: boolean\n}\n\nexport type DerivedFormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = {\n  /**\n   * A boolean indicating if the form is currently validating.\n   */\n  isFormValidating: boolean\n  /**\n   * A boolean indicating if the form is valid.\n   */\n  isFormValid: boolean\n  /**\n   * The error array for the form itself.\n   */\n  errors: Array<\n    | UnwrapFormValidateOrFn<TOnMount>\n    | UnwrapFormValidateOrFn<TOnChange>\n    | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n    | UnwrapFormValidateOrFn<TOnBlur>\n    | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n    | UnwrapFormValidateOrFn<TOnSubmit>\n    | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n    | UnwrapFormAsyncValidateOrFn<TOnServer>\n  >\n  /**\n   * A boolean indicating if any of the form fields are currently validating.\n   */\n  isFieldsValidating: boolean\n  /**\n   * A boolean indicating if all the form fields are valid. Evaluates `true` if there are no field errors.\n   */\n  isFieldsValid: boolean\n  /**\n   * A boolean indicating if any of the form fields have been touched.\n   */\n  isTouched: boolean\n  /**\n   * A boolean indicating if any of the form fields have been blurred.\n   */\n  isBlurred: boolean\n  /**\n   * A boolean indicating if any of the form's fields' values have been modified by the user. Evaluates `true` if the user have modified at least one of the fields. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A boolean indicating if none of the form's fields' values have been modified by the user. Evaluates `true` if the user have not modified any of the fields. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n  /**\n   * A boolean indicating if all of the form's fields are the same as default values.\n   */\n  isDefaultValue: boolean\n  /**\n   * A boolean indicating if the form and all its fields are valid. Evaluates `true` if there are no errors.\n   */\n  isValid: boolean\n  /**\n   * A boolean indicating if the form can be submitted based on its current state.\n   */\n  canSubmit: boolean\n  /**\n   * A record of field metadata for each field in the form.\n   */\n  fieldMeta: Record<DeepKeys<TFormData>, AnyFieldMeta>\n}\n\nexport interface FormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n> extends BaseFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer\n    >,\n    DerivedFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer\n    > {}\n\nexport type AnyFormState = FormState<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\nfunction getDefaultFormState<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n>(\n  defaultState: Partial<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer\n    >\n  >,\n): BaseFormState<\n  TFormData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnServer\n> {\n  return {\n    values: defaultState.values ?? ({} as never),\n    errorMap: defaultState.errorMap ?? {},\n    fieldMetaBase: defaultState.fieldMetaBase ?? ({} as never),\n    isSubmitted: defaultState.isSubmitted ?? false,\n    isSubmitting: defaultState.isSubmitting ?? false,\n    isValidating: defaultState.isValidating ?? false,\n    submissionAttempts: defaultState.submissionAttempts ?? 0,\n    isSubmitSuccessful: defaultState.isSubmitSuccessful ?? false,\n    validationMetaMap: defaultState.validationMetaMap ?? {\n      onChange: undefined,\n      onBlur: undefined,\n      onSubmit: undefined,\n      onMount: undefined,\n      onServer: undefined,\n    },\n  }\n}\n\n/**\n * @public\n *\n * A type representing the Form API with all generics set to `any` for convenience.\n */\nexport type AnyFormApi = FormApi<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * A class representing the Form API. It handles the logic and interactions with the form state.\n *\n * Normally, you will not need to create a new `FormApi` instance directly. Instead, you will use a framework\n * hook/function like `useForm` or `createForm` to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling the `new FormApi` constructor.\n */\nexport class FormApi<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TSubmitMeta = never,\n> {\n  /**\n   * The options for the form.\n   */\n  options: FormOptions<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnServer,\n    TSubmitMeta\n  > = {}\n  baseStore!: Store<\n    BaseFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer\n    >\n  >\n  fieldMetaDerived!: Derived<Record<DeepKeys<TFormData>, AnyFieldMeta>>\n  store!: Derived<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer\n    >\n  >\n  /**\n   * A record of field information for each field in the form.\n   */\n  fieldInfo: Record<DeepKeys<TFormData>, FieldInfo<TFormData>> = {} as any\n\n  get state() {\n    return this.store.state\n  }\n\n  /**\n   * @private\n   */\n  prevTransformArray: unknown[] = []\n\n  /**\n   * Constructs a new `FormApi` instance with the given form options.\n   */\n  constructor(\n    opts?: FormOptions<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) {\n    this.baseStore = new Store(\n      getDefaultFormState({\n        ...(opts?.defaultState as any),\n        values: opts?.defaultValues ?? opts?.defaultState?.values,\n        isFormValid: true,\n      }),\n    )\n\n    this.fieldMetaDerived = new Derived({\n      deps: [this.baseStore],\n      fn: ({ prevDepVals, currDepVals, prevVal: _prevVal }) => {\n        const prevVal = _prevVal as\n          | Record<DeepKeys<TFormData>, AnyFieldMeta>\n          | undefined\n        const prevBaseStore = prevDepVals?.[0]\n        const currBaseStore = currDepVals[0]\n\n        let originalMetaCount = 0\n\n        const fieldMeta = {} as FormState<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnServer\n        >['fieldMeta']\n\n        for (const fieldName of Object.keys(\n          currBaseStore.fieldMetaBase,\n        ) as Array<keyof typeof currBaseStore.fieldMetaBase>) {\n          const currBaseMeta = currBaseStore.fieldMetaBase[\n            fieldName as never\n          ] as AnyFieldMetaBase\n\n          const prevBaseMeta = prevBaseStore?.fieldMetaBase[\n            fieldName as never\n          ] as AnyFieldMetaBase | undefined\n\n          const prevFieldInfo =\n            prevVal?.[fieldName as never as keyof typeof prevVal]\n\n          const curFieldVal = getBy(currBaseStore.values, fieldName)\n\n          let fieldErrors = prevFieldInfo?.errors\n          if (\n            !prevBaseMeta ||\n            currBaseMeta.errorMap !== prevBaseMeta.errorMap\n          ) {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldErrors = Object.values(currBaseMeta.errorMap ?? {}).filter(\n              (val) => val !== undefined,\n            ) as never\n\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            const fieldInstance = this.getFieldInfo(fieldName)?.instance\n\n            if (fieldInstance && !fieldInstance.options.disableErrorFlat) {\n              fieldErrors = (fieldErrors as undefined | string[])?.flat(\n                1,\n              ) as never\n            }\n          }\n\n          // As primitives, we don't need to aggressively persist the same referential value for performance reasons\n          const isFieldValid = !isNonEmptyArray(fieldErrors ?? [])\n          const isFieldPristine = !currBaseMeta.isDirty\n          const isDefaultValue =\n            evaluate(\n              curFieldVal,\n              getBy(this.options.defaultValues, fieldName),\n            ) ||\n            evaluate(\n              curFieldVal,\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              this.getFieldInfo(fieldName)?.instance?.options.defaultValue,\n            )\n\n          if (\n            prevFieldInfo &&\n            prevFieldInfo.isPristine === isFieldPristine &&\n            prevFieldInfo.isValid === isFieldValid &&\n            prevFieldInfo.isDefaultValue === isDefaultValue &&\n            prevFieldInfo.errors === fieldErrors &&\n            currBaseMeta === prevBaseMeta\n          ) {\n            fieldMeta[fieldName] = prevFieldInfo\n            originalMetaCount++\n            continue\n          }\n\n          fieldMeta[fieldName] = {\n            ...currBaseMeta,\n            errors: fieldErrors,\n            isPristine: isFieldPristine,\n            isValid: isFieldValid,\n            isDefaultValue: isDefaultValue,\n          } as AnyFieldMeta\n        }\n\n        if (!Object.keys(currBaseStore.fieldMetaBase).length) return fieldMeta\n\n        if (\n          prevVal &&\n          originalMetaCount === Object.keys(currBaseStore.fieldMetaBase).length\n        ) {\n          return prevVal\n        }\n\n        return fieldMeta\n      },\n    })\n\n    this.store = new Derived({\n      deps: [this.baseStore, this.fieldMetaDerived],\n      fn: ({ prevDepVals, currDepVals, prevVal: _prevVal }) => {\n        const prevVal = _prevVal as\n          | FormState<\n              TFormData,\n              TOnMount,\n              TOnChange,\n              TOnChangeAsync,\n              TOnBlur,\n              TOnBlurAsync,\n              TOnSubmit,\n              TOnSubmitAsync,\n              TOnServer\n            >\n          | undefined\n        const prevBaseStore = prevDepVals?.[0]\n        const currBaseStore = currDepVals[0]\n        const currFieldMeta = currDepVals[1]\n\n        // Computed state\n        const fieldMetaValues = Object.values(currFieldMeta).filter(\n          Boolean,\n        ) as AnyFieldMeta[]\n\n        const isFieldsValidating = fieldMetaValues.some(\n          (field) => field.isValidating,\n        )\n\n        const isFieldsValid = fieldMetaValues.every((field) => field.isValid)\n\n        const isTouched = fieldMetaValues.some((field) => field.isTouched)\n        const isBlurred = fieldMetaValues.some((field) => field.isBlurred)\n        const isDefaultValue = fieldMetaValues.every(\n          (field) => field.isDefaultValue,\n        )\n\n        const shouldInvalidateOnMount =\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          isTouched && currBaseStore.errorMap?.onMount\n\n        const isDirty = fieldMetaValues.some((field) => field.isDirty)\n        const isPristine = !isDirty\n\n        const hasOnMountError = Boolean(\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          currBaseStore.errorMap?.onMount ||\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldMetaValues.some((f) => f?.errorMap?.onMount),\n        )\n\n        const isValidating = !!isFieldsValidating\n\n        // As `errors` is not a primitive, we need to aggressively persist the same referencial value for performance reasons\n        let errors = prevVal?.errors ?? []\n        if (\n          !prevBaseStore ||\n          currBaseStore.errorMap !== prevBaseStore.errorMap\n        ) {\n          errors = Object.values(currBaseStore.errorMap).reduce<\n            Array<\n              | UnwrapFormValidateOrFn<TOnMount>\n              | UnwrapFormValidateOrFn<TOnChange>\n              | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n              | UnwrapFormValidateOrFn<TOnBlur>\n              | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n              | UnwrapFormValidateOrFn<TOnSubmit>\n              | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n              | UnwrapFormAsyncValidateOrFn<TOnServer>\n            >\n          >((prev, curr) => {\n            if (curr === undefined) return prev\n\n            if (curr && isGlobalFormValidationError(curr)) {\n              prev.push(curr.form as never)\n              return prev\n            }\n            prev.push(curr as never)\n            return prev\n          }, [])\n        }\n\n        const isFormValid = errors.length === 0\n        const isValid = isFieldsValid && isFormValid\n        const submitInvalid = this.options.canSubmitWhenInvalid ?? false\n        const canSubmit =\n          (currBaseStore.submissionAttempts === 0 &&\n            !isTouched &&\n            !hasOnMountError) ||\n          (!isValidating && !currBaseStore.isSubmitting && isValid) ||\n          submitInvalid\n\n        let errorMap = currBaseStore.errorMap\n        if (shouldInvalidateOnMount) {\n          errors = errors.filter(\n            (err) => err !== currBaseStore.errorMap.onMount,\n          )\n          errorMap = Object.assign(errorMap, { onMount: undefined })\n        }\n\n        if (\n          prevVal &&\n          prevBaseStore &&\n          prevVal.errorMap === errorMap &&\n          prevVal.fieldMeta === this.fieldMetaDerived.state &&\n          prevVal.errors === errors &&\n          prevVal.isFieldsValidating === isFieldsValidating &&\n          prevVal.isFieldsValid === isFieldsValid &&\n          prevVal.isFormValid === isFormValid &&\n          prevVal.isValid === isValid &&\n          prevVal.canSubmit === canSubmit &&\n          prevVal.isTouched === isTouched &&\n          prevVal.isBlurred === isBlurred &&\n          prevVal.isPristine === isPristine &&\n          prevVal.isDefaultValue === isDefaultValue &&\n          prevVal.isDirty === isDirty &&\n          evaluate(prevBaseStore, currBaseStore)\n        ) {\n          return prevVal\n        }\n\n        let state = {\n          ...currBaseStore,\n          errorMap,\n          fieldMeta: this.fieldMetaDerived.state,\n          errors,\n          isFieldsValidating,\n          isFieldsValid,\n          isFormValid,\n          isValid,\n          canSubmit,\n          isTouched,\n          isBlurred,\n          isPristine,\n          isDefaultValue,\n          isDirty,\n        } as FormState<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnServer\n        >\n\n        // Only run transform if state has shallowly changed - IE how React.useEffect works\n        const transformArray = this.options.transform?.deps ?? []\n        const shouldTransform =\n          transformArray.length !== this.prevTransformArray.length ||\n          transformArray.some((val, i) => val !== this.prevTransformArray[i])\n\n        if (shouldTransform) {\n          const newObj = Object.assign({}, this, { state })\n          // This mutates the state\n          this.options.transform?.fn(newObj)\n          state = newObj.state\n          this.prevTransformArray = transformArray\n        }\n\n        return state\n      },\n    })\n\n    this.handleSubmit = this.handleSubmit.bind(this)\n\n    this.update(opts || {})\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends TStandardSchemaValidatorValue<TFormData> & {\n      formApi: AnyFormApi\n    },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FormValidateOrFn<TFormData>\n      : FormAsyncValidateOrFn<TFormData>\n    value: TValue\n    type: TType\n  }): unknown {\n    if (isStandardSchemaValidator(props.validate)) {\n      return standardSchemaValidators[props.type](\n        props.value,\n        props.validate,\n      ) as never\n    }\n\n    return (props.validate as FormValidateFn<any>)(props.value) as never\n  }\n\n  mount = () => {\n    const cleanupFieldMetaDerived = this.fieldMetaDerived.mount()\n    const cleanupStoreDerived = this.store.mount()\n    const cleanup = () => {\n      cleanupFieldMetaDerived()\n      cleanupStoreDerived()\n    }\n\n    this.options.listeners?.onMount?.({ formApi: this })\n\n    const { onMount } = this.options.validators || {}\n    if (!onMount) return cleanup\n    this.validateSync('mount')\n\n    return cleanup\n  }\n\n  /**\n   * Updates the form options and form state.\n   */\n  update = (\n    options?: FormOptions<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) => {\n    if (!options) return\n\n    const oldOptions = this.options\n\n    // Options need to be updated first so that when the store is updated, the state is correct for the derived state\n    this.options = options\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const shouldUpdateReeval = !!options.transform?.deps?.some(\n      (val, i) => val !== this.prevTransformArray[i],\n    )\n\n    const shouldUpdateValues =\n      options.defaultValues &&\n      !evaluate(options.defaultValues, oldOptions.defaultValues) &&\n      !this.state.isTouched\n\n    const shouldUpdateState =\n      !evaluate(options.defaultState, oldOptions.defaultState) &&\n      !this.state.isTouched\n\n    if (!shouldUpdateValues && !shouldUpdateState && !shouldUpdateReeval) return\n\n    batch(() => {\n      this.baseStore.setState(() =>\n        getDefaultFormState(\n          Object.assign(\n            {},\n            this.state as any,\n\n            shouldUpdateState ? options.defaultState : {},\n\n            shouldUpdateValues\n              ? {\n                  values: options.defaultValues,\n                }\n              : {},\n\n            shouldUpdateReeval\n              ? { _force_re_eval: !this.state._force_re_eval }\n              : {},\n          ),\n        ),\n      )\n    })\n  }\n\n  /**\n   * Resets the form state to the default values.\n   * If values are provided, the form will be reset to those values instead and the default values will be updated.\n   *\n   * @param values - Optional values to reset the form to.\n   * @param opts - Optional options to control the reset behavior.\n   */\n  reset = (values?: TFormData, opts?: { keepDefaultValues?: boolean }) => {\n    const { fieldMeta: currentFieldMeta } = this.state\n    const fieldMetaBase = this.resetFieldMeta(currentFieldMeta)\n\n    if (values && !opts?.keepDefaultValues) {\n      this.options = {\n        ...this.options,\n        defaultValues: values,\n      }\n    }\n\n    this.baseStore.setState(() =>\n      getDefaultFormState({\n        ...(this.options.defaultState as any),\n        values:\n          values ??\n          this.options.defaultValues ??\n          this.options.defaultState?.values,\n        fieldMetaBase,\n      }),\n    )\n  }\n\n  /**\n   * Validates all fields using the correct handlers for a given validation cause.\n   */\n  validateAllFields = async (cause: ValidationCause) => {\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<any>[]).forEach(\n        (field) => {\n          if (!field.instance) return\n          const fieldInstance = field.instance\n          // Validate the field\n          fieldValidationPromises.push(\n            // Remember, `validate` is either a sync operation or a promise\n            Promise.resolve().then(() =>\n              fieldInstance.validate(cause, { skipFormValidation: true }),\n            ),\n          )\n          // If any fields are not touched\n          if (!field.instance.state.meta.isTouched) {\n            // Mark them as touched\n            field.instance.setMeta((prev) => ({ ...prev, isTouched: true }))\n          }\n        },\n      )\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates the children of a specified array in the form starting from a given index until the end using the correct handlers for a given validation type.\n   */\n  validateArrayFieldsStartingFrom = async <\n    TField extends DeepKeysOfType<TFormData, any[]>,\n  >(\n    field: TField,\n    index: number,\n    cause: ValidationCause,\n  ) => {\n    const currentValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(currentValue)\n      ? Math.max((currentValue as Array<unknown>).length - 1, 0)\n      : null\n\n    // We have to validate all fields that have shifted (at least the current field)\n    const fieldKeysToValidate = [`${field}[${index}]`]\n    for (let i = index + 1; i <= (lastIndex ?? 0); i++) {\n      fieldKeysToValidate.push(`${field}[${i}]`)\n    }\n\n    // We also have to include all fields that are nested in the shifted fields\n    const fieldsToValidate = Object.keys(this.fieldInfo).filter((fieldKey) =>\n      fieldKeysToValidate.some((key) => fieldKey.startsWith(key)),\n    ) as DeepKeys<TFormData>[]\n\n    // Validate the fields\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    batch(() => {\n      fieldsToValidate.forEach((nestedField) => {\n        fieldValidationPromises.push(\n          Promise.resolve().then(() => this.validateField(nestedField, cause)),\n        )\n      })\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates a specified field in the form using the correct handlers for a given validation type.\n   */\n  validateField = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    cause: ValidationCause,\n  ) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const fieldInstance = this.fieldInfo[field]?.instance\n    if (!fieldInstance) return []\n\n    // If the field is not touched (same logic as in validateAllFields)\n    if (!fieldInstance.state.meta.isTouched) {\n      // Mark it as touched\n      fieldInstance.setMeta((prev) => ({ ...prev, isTouched: true }))\n    }\n\n    return fieldInstance.validate(cause)\n  }\n\n  /**\n   * TODO: This code is copied from FieldApi, we should refactor to share\n   * @private\n   */\n  validateSync = (\n    cause: ValidationCause,\n  ): {\n    hasErrored: boolean\n    fieldsErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync\n    >\n  } => {\n    const validates = getSyncValidatorArray(cause, this.options)\n    let hasErrored = false as boolean\n\n    // This map will only include fields that have errors in the current validation cycle\n    const currentValidationErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync\n    > = {}\n\n    batch(() => {\n      for (const validateObj of validates) {\n        if (!validateObj.validate) continue\n\n        const rawError = this.runValidator({\n          validate: validateObj.validate,\n          value: {\n            value: this.state.values,\n            formApi: this,\n            validationSource: 'form',\n          },\n          type: 'validate',\n        })\n\n        const { formError, fieldErrors } = normalizeError<TFormData>(rawError)\n\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n\n        for (const field of Object.keys(\n          this.state.fieldMeta,\n        ) as DeepKeys<TFormData>[]) {\n          const fieldMeta = this.getFieldMeta(field)\n          if (!fieldMeta) continue\n\n          const {\n            errorMap: currentErrorMap,\n            errorSourceMap: currentErrorMapSource,\n          } = fieldMeta\n\n          const newFormValidatorError = fieldErrors?.[field]\n\n          const { newErrorValue, newSource } =\n            determineFormLevelErrorSourceAndValue({\n              newFormValidatorError,\n              isPreviousErrorFromFormValidator:\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                currentErrorMapSource?.[errorMapKey] === 'form',\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              previousErrorValue: currentErrorMap?.[errorMapKey],\n            })\n\n          if (newSource === 'form') {\n            currentValidationErrorMap[field] = {\n              ...currentValidationErrorMap[field],\n              [errorMapKey]: newFormValidatorError,\n            }\n          }\n\n          if (\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            currentErrorMap?.[errorMapKey] !== newErrorValue\n          ) {\n            this.setFieldMeta(field, (prev) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [errorMapKey]: newErrorValue,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: newSource,\n              },\n            }))\n          }\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (this.state.errorMap?.[errorMapKey] !== formError) {\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n        }\n\n        if (formError || fieldErrors) {\n          hasErrored = true\n        }\n      }\n\n      /**\n       *  when we have an error for onSubmit in the state, we want\n       *  to clear the error as soon as the user enters a valid value in the field\n       */\n      const submitErrKey = getErrorMapKey('submit')\n      if (\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        this.state.errorMap?.[submitErrKey] &&\n        cause !== 'submit' &&\n        !hasErrored\n      ) {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          errorMap: {\n            ...prev.errorMap,\n            [submitErrKey]: undefined,\n          },\n        }))\n      }\n    })\n\n    return { hasErrored, fieldsErrorMap: currentValidationErrorMap }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n  ): Promise<\n    FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync\n    >\n  > => {\n    const validates = getAsyncValidatorArray(cause, this.options)\n\n    if (!this.state.isFormValidating) {\n      this.baseStore.setState((prev) => ({ ...prev, isFormValidating: true }))\n    }\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const promises: Promise<ValidationPromiseResult<TFormData>>[] = []\n\n    let fieldErrorsFromFormValidators:\n      | Partial<Record<DeepKeys<TFormData>, ValidationError>>\n      | undefined\n\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      const key = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = this.state.validationMetaMap[key]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.state.validationMetaMap[key] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationPromiseResult<TFormData>>(async (resolve) => {\n          let rawError!:\n            | ValidationError\n            | FormValidationError<unknown>\n            | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              setTimeout(async () => {\n                if (controller.signal.aborted) return rawResolve(undefined)\n                try {\n                  rawResolve(\n                    await this.runValidator({\n                      validate: validateObj.validate!,\n                      value: {\n                        value: this.state.values,\n                        formApi: this,\n                        validationSource: 'form',\n                        signal: controller.signal,\n                      },\n                      type: 'validateAsync',\n                    }),\n                  )\n                } catch (e) {\n                  rawReject(e)\n                }\n              }, validateObj.debounceMs)\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          const { formError, fieldErrors: fieldErrorsFromNormalizeError } =\n            normalizeError<TFormData>(rawError)\n\n          if (fieldErrorsFromNormalizeError) {\n            fieldErrorsFromFormValidators = fieldErrorsFromFormValidators\n              ? {\n                  ...fieldErrorsFromFormValidators,\n                  ...fieldErrorsFromNormalizeError,\n                }\n              : fieldErrorsFromNormalizeError\n          }\n          const errorMapKey = getErrorMapKey(validateObj.cause)\n\n          for (const field of Object.keys(\n            this.state.fieldMeta,\n          ) as DeepKeys<TFormData>[]) {\n            const fieldMeta = this.getFieldMeta(field)\n            if (!fieldMeta) continue\n\n            const {\n              errorMap: currentErrorMap,\n              errorSourceMap: currentErrorMapSource,\n            } = fieldMeta\n\n            const newFormValidatorError = fieldErrorsFromFormValidators?.[field]\n\n            const { newErrorValue, newSource } =\n              determineFormLevelErrorSourceAndValue({\n                newFormValidatorError,\n                isPreviousErrorFromFormValidator:\n                  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                  currentErrorMapSource?.[errorMapKey] === 'form',\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                previousErrorValue: currentErrorMap?.[errorMapKey],\n              })\n\n            if (\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              currentErrorMap?.[errorMapKey] !== newErrorValue\n            ) {\n              this.setFieldMeta(field, (prev) => ({\n                ...prev,\n                errorMap: {\n                  ...prev.errorMap,\n                  [errorMapKey]: newErrorValue,\n                },\n                errorSourceMap: {\n                  ...prev.errorSourceMap,\n                  [errorMapKey]: newSource,\n                },\n              }))\n            }\n          }\n\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n\n          resolve(\n            fieldErrorsFromFormValidators\n              ? { fieldErrors: fieldErrorsFromFormValidators, errorMapKey }\n              : undefined,\n          )\n        }),\n      )\n    }\n\n    let results: ValidationPromiseResult<TFormData>[] = []\n\n    const fieldsErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync\n    > = {}\n    if (promises.length) {\n      results = await Promise.all(promises)\n      for (const fieldValidationResult of results) {\n        if (fieldValidationResult?.fieldErrors) {\n          const { errorMapKey } = fieldValidationResult\n\n          for (const [field, fieldError] of Object.entries(\n            fieldValidationResult.fieldErrors,\n          )) {\n            const oldErrorMap =\n              fieldsErrorMap[field as DeepKeys<TFormData>] || {}\n            const newErrorMap = {\n              ...oldErrorMap,\n              [errorMapKey]: fieldError,\n            }\n            fieldsErrorMap[field as DeepKeys<TFormData>] = newErrorMap\n          }\n        }\n      }\n    }\n\n    this.baseStore.setState((prev) => ({\n      ...prev,\n      isFormValidating: false,\n    }))\n\n    return fieldsErrorMap\n  }\n\n  /**\n   * @private\n   */\n  validate = (\n    cause: ValidationCause,\n  ):\n    | FormErrorMapFromValidator<\n        TFormData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync\n      >\n    | Promise<\n        FormErrorMapFromValidator<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync\n        >\n      > => {\n    // Attempt to sync validate first\n    const { hasErrored, fieldsErrorMap } = this.validateSync(cause)\n\n    if (hasErrored && !this.options.asyncAlways) {\n      return fieldsErrorMap\n    }\n\n    // No error? Attempt async validation\n    return this.validateAsync(cause)\n  }\n\n  /**\n   * Handles the form submission, performs validation, and calls the appropriate onSubmit or onSubmitInvalid callbacks.\n   */\n  handleSubmit(): Promise<void>\n  handleSubmit(submitMeta: TSubmitMeta): Promise<void>\n  async handleSubmit(submitMeta?: TSubmitMeta): Promise<void> {\n    this.baseStore.setState((old) => ({\n      ...old,\n      // Submission attempts mark the form as not submitted\n      isSubmitted: false,\n      // Count submission attempts\n      submissionAttempts: old.submissionAttempts + 1,\n      isSubmitSuccessful: false, // Reset isSubmitSuccessful at the start of submission\n    }))\n\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<any>[]).forEach(\n        (field) => {\n          if (!field.instance) return\n          // If any fields are not touched\n          if (!field.instance.state.meta.isTouched) {\n            // Mark them as touched\n            field.instance.setMeta((prev) => ({ ...prev, isTouched: true }))\n          }\n        },\n      )\n    })\n\n    if (!this.state.canSubmit) return\n\n    this.baseStore.setState((d) => ({ ...d, isSubmitting: true }))\n\n    const done = () => {\n      this.baseStore.setState((prev) => ({ ...prev, isSubmitting: false }))\n    }\n\n    await this.validateAllFields('submit')\n\n    if (!this.state.isFieldsValid) {\n      done()\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n      })\n      return\n    }\n\n    await this.validate('submit')\n\n    // Fields are invalid, do not submit\n    if (!this.state.isValid) {\n      done()\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n      })\n      return\n    }\n\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<TFormData>[]).forEach(\n        (field) => {\n          field.instance?.options.listeners?.onSubmit?.({\n            value: field.instance.state.value,\n            fieldApi: field.instance,\n          })\n        },\n      )\n    })\n\n    this.options.listeners?.onSubmit?.({ formApi: this })\n\n    try {\n      // Run the submit code\n      await this.options.onSubmit?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMeta ?? this.options.onSubmitMeta,\n      } as any)\n\n      batch(() => {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          isSubmitted: true,\n          isSubmitSuccessful: true, // Set isSubmitSuccessful to true on successful submission\n        }))\n        done()\n      })\n    } catch (err) {\n      this.baseStore.setState((prev) => ({\n        ...prev,\n        isSubmitSuccessful: false, // Ensure isSubmitSuccessful is false if an error occurs\n      }))\n      done()\n      throw err\n    }\n  }\n\n  /**\n   * Gets the value of the specified field.\n   */\n  getFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): DeepValue<TFormData, TField> => getBy(this.state.values, field)\n\n  /**\n   * Gets the metadata of the specified field.\n   */\n  getFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): AnyFieldMeta | undefined => {\n    return this.state.fieldMeta[field]\n  }\n\n  /**\n   * Gets the field info of the specified field.\n   */\n  getFieldInfo = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): FieldInfo<TFormData> => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return (this.fieldInfo[field] ||= {\n      instance: null,\n      validationMetaMap: {\n        onChange: undefined,\n        onBlur: undefined,\n        onSubmit: undefined,\n        onMount: undefined,\n        onServer: undefined,\n      },\n    })\n  }\n\n  /**\n   * Updates the metadata of the specified field.\n   */\n  setFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<AnyFieldMetaBase>,\n  ) => {\n    this.baseStore.setState((prev) => {\n      return {\n        ...prev,\n        fieldMetaBase: {\n          ...prev.fieldMetaBase,\n          [field]: functionalUpdate(\n            updater,\n            prev.fieldMetaBase[field] as never,\n          ),\n        },\n      }\n    })\n  }\n\n  /**\n   * resets every field's meta\n   */\n  resetFieldMeta = <TField extends DeepKeys<TFormData>>(\n    fieldMeta: Record<TField, AnyFieldMeta>,\n  ): Record<TField, AnyFieldMeta> => {\n    return Object.keys(fieldMeta).reduce(\n      (acc: Record<TField, AnyFieldMeta>, key) => {\n        const fieldKey = key as TField\n        acc[fieldKey] = defaultFieldMeta\n        return acc\n      },\n      {} as Record<TField, AnyFieldMeta>,\n    )\n  }\n\n  /**\n   * Sets the value of the specified field and optionally updates the touched state.\n   */\n  setFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<DeepValue<TFormData, TField>>,\n    opts?: UpdateMetaOptions,\n  ) => {\n    const dontUpdateMeta = opts?.dontUpdateMeta ?? false\n\n    batch(() => {\n      if (!dontUpdateMeta) {\n        this.setFieldMeta(field, (prev) => ({\n          ...prev,\n          isTouched: true,\n          isDirty: true,\n          errorMap: {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            ...prev?.errorMap,\n            onMount: undefined,\n          },\n        }))\n      }\n\n      this.baseStore.setState((prev) => {\n        return {\n          ...prev,\n          values: setBy(prev.values, field, updater),\n        }\n      })\n    })\n  }\n\n  deleteField = <TField extends DeepKeys<TFormData>>(field: TField) => {\n    const subFieldsToDelete = Object.keys(this.fieldInfo).filter((f) => {\n      const fieldStr = field.toString()\n      return f !== fieldStr && f.startsWith(fieldStr)\n    })\n\n    const fieldsToDelete = [...subFieldsToDelete, field]\n\n    // Cleanup the last fields\n    this.baseStore.setState((prev) => {\n      const newState = { ...prev }\n      fieldsToDelete.forEach((f) => {\n        newState.values = deleteBy(newState.values, f)\n        delete this.fieldInfo[f as never]\n        delete newState.fieldMetaBase[f as never]\n      })\n\n      return newState\n    })\n  }\n\n  /**\n   * Pushes a value into an array field.\n   */\n  pushFieldValue = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => [...(Array.isArray(prev) ? prev : []), value] as any,\n      opts,\n    )\n    this.validateField(field, 'change')\n  }\n\n  insertFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return [\n          ...(prev as DeepValue<TFormData, TField>[]).slice(0, index),\n          value,\n          ...(prev as DeepValue<TFormData, TField>[]).slice(index),\n        ] as any\n      },\n      opts,\n    )\n\n    // Validate the whole array + all fields that have shifted\n    await this.validateField(field, 'change')\n\n    // Shift down all meta after validating to make sure the new field has been mounted\n    metaHelper(this).handleArrayFieldMetaShift(field, index, 'insert')\n\n    await this.validateArrayFieldsStartingFrom(field, index, 'change')\n  }\n\n  /**\n   * Replaces a value into an array field at the specified index.\n   */\n  replaceFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).map((d, i) =>\n          i === index ? value : d,\n        ) as any\n      },\n      opts,\n    )\n\n    // Validate the whole array + all fields that have shifted\n    await this.validateField(field, 'change')\n    await this.validateArrayFieldsStartingFrom(field, index, 'change')\n  }\n\n  /**\n   * Removes a value from an array field at the specified index.\n   */\n  removeFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    opts?: UpdateMetaOptions,\n  ) => {\n    const fieldValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(fieldValue)\n      ? Math.max((fieldValue as Array<unknown>).length - 1, 0)\n      : null\n\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).filter(\n          (_d, i) => i !== index,\n        ) as any\n      },\n      opts,\n    )\n\n    // Shift up all meta\n    metaHelper(this).handleArrayFieldMetaShift(field, index, 'remove')\n\n    if (lastIndex !== null) {\n      const start = `${field}[${lastIndex}]`\n      this.deleteField(start as never)\n    }\n\n    // Validate the whole array + all fields that have shifted\n    await this.validateField(field, 'change')\n    await this.validateArrayFieldsStartingFrom(field, index, 'change')\n  }\n\n  /**\n   * Swaps the values at the specified indices within an array field.\n   */\n  swapFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        const prev1 = prev[index1]!\n        const prev2 = prev[index2]!\n        return setBy(setBy(prev, `${index1}`, prev2), `${index2}`, prev1)\n      },\n      opts,\n    )\n\n    // Swap meta\n    metaHelper(this).handleArrayFieldMetaShift(field, index1, 'swap', index2)\n\n    // Validate the whole array\n    this.validateField(field, 'change')\n    // Validate the swapped fields\n    this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n    this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n  }\n\n  /**\n   * Moves the value at the first specified index to the second specified index within an array field.\n   */\n  moveFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        const next: any = [...prev]\n        next.splice(index2, 0, next.splice(index1, 1)[0])\n        return next\n      },\n      opts,\n    )\n\n    // Move meta between index1 and index2\n    metaHelper(this).handleArrayFieldMetaShift(field, index1, 'move', index2)\n\n    // Validate the whole array\n    this.validateField(field, 'change')\n    // Validate the moved fields\n    this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n    this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n  }\n\n  /**\n   * Clear all values within an array field.\n   */\n  clearFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    opts?: UpdateMetaOptions,\n  ) => {\n    const fieldValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(fieldValue)\n      ? Math.max((fieldValue as unknown[]).length - 1, 0)\n      : null\n\n    this.setFieldValue(field, [] as any, opts)\n\n    if (lastIndex !== null) {\n      for (let i = 0; i <= lastIndex; i++) {\n        const fieldKey = `${field}[${i}]`\n        this.deleteField(fieldKey as never)\n      }\n    }\n\n    // validate array change\n    this.validateField(field, 'change')\n  }\n\n  /**\n   * Resets the field value and meta to default state\n   */\n  resetField = <TField extends DeepKeys<TFormData>>(field: TField) => {\n    this.baseStore.setState((prev) => {\n      return {\n        ...prev,\n        fieldMetaBase: {\n          ...prev.fieldMetaBase,\n          [field]: defaultFieldMeta,\n        },\n        values: this.options.defaultValues\n          ? setBy(prev.values, field, getBy(this.options.defaultValues, field))\n          : prev.values,\n      }\n    })\n  }\n\n  /**\n   * Updates the form's errorMap\n   */\n  setErrorMap(\n    errorMap: FormValidationErrorMap<\n      TFormData,\n      UnwrapFormValidateOrFn<TOnMount>,\n      UnwrapFormValidateOrFn<TOnChange>,\n      UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n      UnwrapFormValidateOrFn<TOnBlur>,\n      UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n      UnwrapFormValidateOrFn<TOnSubmit>,\n      UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n      UnwrapFormAsyncValidateOrFn<TOnServer>\n    >,\n  ) {\n    batch(() => {\n      Object.entries(errorMap).forEach(([key, value]) => {\n        const errorMapKey = key as ValidationErrorMapKeys\n\n        if (isGlobalFormValidationError(value)) {\n          const { formError, fieldErrors } = normalizeError<TFormData>(value)\n\n          for (const fieldName of Object.keys(\n            this.fieldInfo,\n          ) as DeepKeys<TFormData>[]) {\n            const fieldMeta = this.getFieldMeta(fieldName)\n            if (!fieldMeta) continue\n\n            this.setFieldMeta(fieldName, (prev) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [errorMapKey]: fieldErrors?.[fieldName],\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: 'form',\n              },\n            }))\n          }\n\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n        } else {\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: value,\n            },\n          }))\n        }\n      })\n    })\n  }\n\n  /**\n   * Returns form and field level errors\n   */\n  getAllErrors = (): {\n    form: {\n      errors: Array<\n        | UnwrapFormValidateOrFn<TOnMount>\n        | UnwrapFormValidateOrFn<TOnChange>\n        | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n        | UnwrapFormValidateOrFn<TOnBlur>\n        | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n        | UnwrapFormValidateOrFn<TOnSubmit>\n        | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n        | UnwrapFormAsyncValidateOrFn<TOnServer>\n      >\n      errorMap: ValidationErrorMap<\n        UnwrapFormValidateOrFn<TOnMount>,\n        UnwrapFormValidateOrFn<TOnChange>,\n        UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n        UnwrapFormValidateOrFn<TOnBlur>,\n        UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n        UnwrapFormValidateOrFn<TOnSubmit>,\n        UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n        UnwrapFormAsyncValidateOrFn<TOnServer>\n      >\n    }\n    fields: Record<\n      DeepKeys<TFormData>,\n      { errors: ValidationError[]; errorMap: ValidationErrorMap }\n    >\n  } => {\n    return {\n      form: {\n        errors: this.state.errors,\n        errorMap: this.state.errorMap,\n      },\n      fields: Object.entries(this.state.fieldMeta).reduce(\n        (acc, [fieldName, fieldMeta]) => {\n          if (\n            Object.keys(fieldMeta as AnyFieldMeta).length &&\n            (fieldMeta as AnyFieldMeta).errors.length\n          ) {\n            acc[fieldName as DeepKeys<TFormData>] = {\n              errors: (fieldMeta as AnyFieldMeta).errors,\n              errorMap: (fieldMeta as AnyFieldMeta).errorMap,\n            }\n          }\n\n          return acc\n        },\n        {} as Record<\n          DeepKeys<TFormData>,\n          { errors: ValidationError[]; errorMap: ValidationErrorMap }\n        >,\n      ),\n    }\n  }\n\n  /**\n   * Parses the form's values with a given standard schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse the form values with.\n   */\n  parseValuesWithSchema = (schema: StandardSchemaV1<TFormData, unknown>) => {\n    return standardSchemaValidators.validate(\n      { value: this.state.values, validationSource: 'form' },\n      schema,\n    )\n  }\n\n  /**\n   * Parses the form's values with a given standard schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse the form values with.\n   */\n  parseValuesWithSchemaAsync = (\n    schema: StandardSchemaV1<TFormData, unknown>,\n  ) => {\n    return standardSchemaValidators.validateAsync(\n      { value: this.state.values, validationSource: 'form' },\n      schema,\n    )\n  }\n}\n\nfunction normalizeError<TFormData>(rawError?: FormValidationError<unknown>): {\n  formError: ValidationError\n  fieldErrors?: Partial<Record<DeepKeys<TFormData>, ValidationError>>\n} {\n  if (rawError) {\n    if (isGlobalFormValidationError(rawError)) {\n      const formError = normalizeError(rawError.form).formError\n      const fieldErrors = rawError.fields\n      return { formError, fieldErrors } as never\n    }\n\n    return { formError: rawError }\n  }\n\n  return { formError: undefined }\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n", "import { Derived, batch } from '@tanstack/store'\nimport {\n  isStandardSchemaValidator,\n  standardSchemaValidators,\n} from './standardSchemaValidator'\nimport { defaultFieldMeta } from './metaHelper'\nimport {\n  determineFieldLevelErrorSourceAndValue,\n  getAsyncValidatorArray,\n  getBy,\n  getSyncValidatorArray,\n} from './utils'\nimport type { DeepKeys, DeepValue, UnwrapOneLevelOfArray } from './util-types'\nimport type {\n  StandardSchemaV1,\n  StandardSchemaV1Issue,\n  TStandardSchemaValidatorValue,\n} from './standardSchemaValidator'\nimport type {\n  FieldInfo,\n  FormApi,\n  FormAsyncValidateOrFn,\n  FormValidateAsyncFn,\n  FormValidateFn,\n  FormValidateOrFn,\n} from './FormApi'\nimport type {\n  ListenerCause,\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationErrorMapSource,\n} from './types'\nimport type { AsyncValidator, SyncValidator, Updater } from './utils'\n\n/**\n * @private\n */\n// TODO: Add the `Unwrap` type to the errors\ntype FieldErrorMapFromValidator<\n  TFormData,\n  TName extends DeepKeys<TFormData>,\n  TData extends DeepValue<TFormData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n> = Partial<\n  Record<\n    DeepKeys<TFormData>,\n    ValidationErrorMap<\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync\n    >\n  >\n>\n\n/**\n * @private\n */\nexport type FieldValidateFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => unknown\n\n/**\n * @private\n */\nexport type FieldValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | FieldValidateFn<TParentData, TName, TData>\n  | StandardSchemaV1<TData, unknown>\n\ntype StandardBrandedSchemaV1<T> = T & { __standardSchemaV1: true }\n\ntype UnwrapFormValidateOrFnForInner<\n  TValidateOrFn extends undefined | FormValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateFn<any>]\n  ? ReturnType<TValidateOrFn>\n  : [TValidateOrFn] extends [StandardSchemaV1<infer TOut, any>]\n    ? StandardBrandedSchemaV1<TOut>\n    : undefined\n\nexport type UnwrapFieldValidateOrFn<\n  TName extends string,\n  TValidateOrFn extends undefined | FieldValidateOrFn<any, any, any>,\n  TFormValidateOrFn extends undefined | FormValidateOrFn<any>,\n> =\n  | ([TFormValidateOrFn] extends [StandardSchemaV1<any, infer TStandardOut>]\n      ? TName extends keyof TStandardOut\n        ? StandardSchemaV1Issue[]\n        : undefined\n      : undefined)\n  | (UnwrapFormValidateOrFnForInner<TFormValidateOrFn> extends infer TFormValidateVal\n      ? TFormValidateVal extends { __standardSchemaV1: true }\n        ? [DeepValue<TFormValidateVal, TName>] extends [never]\n          ? undefined\n          : StandardSchemaV1Issue[]\n        : TFormValidateVal extends { fields: any }\n          ? TName extends keyof TFormValidateVal['fields']\n            ? TFormValidateVal['fields'][TName]\n            : undefined\n          : undefined\n      : never)\n  | ([TValidateOrFn] extends [FieldValidateFn<any, any, any>]\n      ? ReturnType<TValidateOrFn>\n      : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n        ? // TODO: Check if `disableErrorFlat` is enabled, if so, return StandardSchemaV1Issue[][]\n          StandardSchemaV1Issue[]\n        : undefined)\n\n/**\n * @private\n */\nexport type FieldValidateAsyncFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (options: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n  signal: AbortSignal\n}) => unknown | Promise<unknown>\n\n/**\n * @private\n */\nexport type FieldAsyncValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | FieldValidateAsyncFn<TParentData, TName, TData>\n  | StandardSchemaV1<TData, unknown>\n\ntype UnwrapFormAsyncValidateOrFnForInner<\n  TValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateAsyncFn<any>]\n  ? Awaited<ReturnType<TValidateOrFn>>\n  : [TValidateOrFn] extends [StandardSchemaV1<infer TOut, any>]\n    ? StandardBrandedSchemaV1<TOut>\n    : undefined\n\nexport type UnwrapFieldAsyncValidateOrFn<\n  TName extends string,\n  TValidateOrFn extends undefined | FieldAsyncValidateOrFn<any, any, any>,\n  TFormValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> =\n  | ([TFormValidateOrFn] extends [StandardSchemaV1<any, infer TStandardOut>]\n      ? TName extends keyof TStandardOut\n        ? StandardSchemaV1Issue[]\n        : undefined\n      : undefined)\n  | (UnwrapFormAsyncValidateOrFnForInner<TFormValidateOrFn> extends infer TFormValidateVal\n      ? TFormValidateVal extends { __standardSchemaV1: true }\n        ? [DeepValue<TFormValidateVal, TName>] extends [never]\n          ? undefined\n          : StandardSchemaV1Issue[]\n        : TFormValidateVal extends { fields: any }\n          ? TName extends keyof TFormValidateVal['fields']\n            ? TFormValidateVal['fields'][TName]\n            : undefined\n          : undefined\n      : never)\n  | ([TValidateOrFn] extends [FieldValidateAsyncFn<any, any, any>]\n      ? Awaited<ReturnType<TValidateOrFn>>\n      : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n        ? // TODO: Check if `disableErrorFlat` is enabled, if so, return StandardSchemaV1Issue[][]\n          StandardSchemaV1Issue[]\n        : undefined)\n\n/**\n * @private\n */\nexport type FieldListenerFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field listener function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => void\n\nexport interface FieldValidators<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n> {\n  /**\n   * An optional function, that runs on the mount event of input.\n   */\n  onMount?: TOnMount\n  /**\n   * An optional function, that runs on the change event of input.\n   *\n   * @example z.string().min(1)\n   */\n  onChange?: TOnChange\n  /**\n   * An optional property similar to `onChange` but async validation\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onChangeAsync?: TOnChangeAsync\n  /**\n   * An optional number to represent how long the `onChangeAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onChange` and `onChangeAsync` events when its value changes\n   */\n  onChangeListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the blur event of input.\n   *\n   * @example z.string().min(1)\n   */\n  onBlur?: TOnBlur\n  /**\n   * An optional property similar to `onBlur` but async validation.\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onBlurAsync?: TOnBlurAsync\n\n  /**\n   * An optional number to represent how long the `onBlurAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onBlurAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onBlur` and `onBlurAsync` events when its value changes\n   */\n  onBlurListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the submit event of form.\n   *\n   * @example z.string().min(1)\n   */\n  onSubmit?: TOnSubmit\n  /**\n   * An optional property similar to `onSubmit` but async validation.\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onSubmitAsync?: TOnSubmitAsync\n}\n\nexport interface FieldListeners<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> {\n  onChange?: FieldListenerFn<TParentData, TName, TData>\n  onChangeDebounceMs?: number\n  onBlur?: FieldListenerFn<TParentData, TName, TData>\n  onBlurDebounceMs?: number\n  onMount?: FieldListenerFn<TParentData, TName, TData>\n  onSubmit?: FieldListenerFn<TParentData, TName, TData>\n}\n\n/**\n * An object type representing the options for a field in a form.\n */\nexport interface FieldOptions<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n> {\n  /**\n   * The field name. The type will be `DeepKeys<TParentData>` to ensure your name is a deep key of the parent dataset.\n   */\n  name: TName\n  /**\n   * An optional default value for the field.\n   */\n  defaultValue?: NoInfer<TData>\n  /**\n   * The default time to debounce async validation if there is not a more specific debounce time passed.\n   */\n  asyncDebounceMs?: number\n  /**\n   * If `true`, always run async validation, even if there are errors emitted during synchronous validation.\n   */\n  asyncAlways?: boolean\n  /**\n   * A list of validators to pass to the field\n   */\n  validators?: FieldValidators<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync\n  >\n  /**\n   * An optional object with default metadata for the field.\n   */\n  defaultMeta?: Partial<\n    FieldMeta<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any\n    >\n  >\n  /**\n   * A list of listeners which attach to the corresponding events\n   */\n  listeners?: FieldListeners<TParentData, TName, TData>\n  /**\n   * Disable the `flat(1)` operation on `field.errors`. This is useful if you want to keep the error structure as is. Not suggested for most use-cases.\n   */\n  disableErrorFlat?: boolean\n}\n\n/**\n * An object type representing the required options for the FieldApi class.\n */\nexport interface FieldApiOptions<\n  in out TParentData,\n  in out TName extends DeepKeys<TParentData>,\n  in out TData extends DeepValue<TParentData, TName>,\n  in out TOnMount extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChange extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlur extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmit extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChangeAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnBlurAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnSubmitAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  in out TParentSubmitMeta,\n> extends FieldOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync\n  > {\n  form: FormApi<\n    TParentData,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  >\n}\n\nexport type FieldMetaBase<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * A flag indicating whether the field has been touched.\n   */\n  isTouched: boolean\n  /**\n   * A flag indicating whether the field has been blurred.\n   */\n  isBlurred: boolean\n  /**\n   * A flag that is `true` if the field's value has been modified by the user. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A map of errors related to the field value.\n   */\n  errorMap: ValidationErrorMap<\n    UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>,\n    UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>\n  >\n  /**\n   * @private allows tracking the source of the errors in the error map\n   */\n  errorSourceMap: ValidationErrorMapSource\n  /**\n   * A flag indicating whether the field is currently being validated.\n   */\n  isValidating: boolean\n}\n\nexport type AnyFieldMetaBase = FieldMetaBase<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type FieldMetaDerived<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * An array of errors related to the field value.\n   */\n  errors: Array<\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>\n      >\n  >\n  /**\n   * A flag that is `true` if the field's value has not been modified by the user. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n  /**\n   * A boolean indicating if the field is valid. Evaluates `true` if there are no field errors.\n   */\n  isValid: boolean\n  /**\n   * A flag indicating whether the field's current value is the default value\n   */\n  isDefaultValue: boolean\n}\n\nexport type AnyFieldMetaDerived = FieldMetaDerived<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object type representing the metadata of a field in a form.\n */\nexport type FieldMeta<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = FieldMetaBase<\n  TParentData,\n  TName,\n  TData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TFormOnMount,\n  TFormOnChange,\n  TFormOnChangeAsync,\n  TFormOnBlur,\n  TFormOnBlurAsync,\n  TFormOnSubmit,\n  TFormOnSubmitAsync\n> &\n  FieldMetaDerived<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync\n  >\n\nexport type AnyFieldMeta = FieldMeta<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object type representing the state of a field.\n */\nexport type FieldState<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * The current value of the field.\n   */\n  value: TData\n  /**\n   * The current metadata of the field.\n   */\n  meta: FieldMeta<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync\n  >\n}\n\n/**\n * @public\n *\n * A type representing the Field API with all generics set to `any` for convenience.\n */\nexport type AnyFieldApi = FieldApi<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * A class representing the API for managing a form field.\n *\n * Normally, you will not need to create a new `FieldApi` instance directly.\n * Instead, you will use a framework hook/function like `useField` or `createField`\n * to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling\n * the `new FieldApi` constructor.\n */\nexport class FieldApi<\n  in out TParentData,\n  in out TName extends DeepKeys<TParentData>,\n  in out TData extends DeepValue<TParentData, TName>,\n  in out TOnMount extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChange extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlur extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmit extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChangeAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnBlurAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnSubmitAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  in out TParentSubmitMeta,\n> {\n  /**\n   * A reference to the form API instance.\n   */\n  form: FieldApiOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  >['form']\n  /**\n   * The field name.\n   */\n  name!: DeepKeys<TParentData>\n  /**\n   * The field options.\n   */\n  options: FieldApiOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  > = {} as any\n  /**\n   * The field state store.\n   */\n  store!: Derived<\n    FieldState<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync\n    >\n  >\n  /**\n   * The current field state.\n   */\n  get state() {\n    return this.store.state\n  }\n  timeoutIds: {\n    validations: Record<ValidationCause, ReturnType<typeof setTimeout> | null>\n    listeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n    formListeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n  }\n\n  /**\n   * Initializes a new `FieldApi` instance.\n   */\n  constructor(\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnServer,\n      TParentSubmitMeta\n    >,\n  ) {\n    this.form = opts.form as never\n    this.name = opts.name as never\n    this.timeoutIds = {\n      validations: {} as Record<ValidationCause, never>,\n      listeners: {} as Record<ListenerCause, never>,\n      formListeners: {} as Record<ListenerCause, never>,\n    }\n\n    this.store = new Derived({\n      deps: [this.form.store],\n      fn: () => {\n        const value = this.form.getFieldValue(this.name)\n        const meta = this.form.getFieldMeta(this.name) ?? {\n          ...defaultFieldMeta,\n          ...opts.defaultMeta,\n        }\n\n        return {\n          value,\n          meta,\n        } as FieldState<\n          TParentData,\n          TName,\n          TData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TFormOnMount,\n          TFormOnChange,\n          TFormOnChangeAsync,\n          TFormOnBlur,\n          TFormOnBlurAsync,\n          TFormOnSubmit,\n          TFormOnSubmitAsync\n        >\n      },\n    })\n\n    this.options = opts as never\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends TStandardSchemaValidatorValue<TData> & {\n      fieldApi: AnyFieldApi\n    },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FieldValidateOrFn<any, any, any>\n      : FieldAsyncValidateOrFn<any, any, any>\n    value: TValue\n    type: TType\n    // When `api` is 'field', the return type cannot be `FormValidationError`\n  }): unknown {\n    if (isStandardSchemaValidator(props.validate)) {\n      return standardSchemaValidators[props.type](\n        props.value,\n        props.validate,\n      ) as never\n    }\n\n    return (props.validate as FieldValidateFn<any, any>)(props.value) as never\n  }\n\n  /**\n   * Mounts the field instance to the form.\n   */\n  mount = () => {\n    const cleanup = this.store.mount()\n\n    if ((this.options.defaultValue as unknown) !== undefined) {\n      this.form.setFieldValue(this.name, this.options.defaultValue as never, {\n        dontUpdateMeta: true,\n      })\n    }\n\n    const info = this.getInfo()\n    info.instance = this as never\n\n    this.update(this.options as never)\n    const { onMount } = this.options.validators || {}\n\n    if (onMount) {\n      const error = this.runValidator({\n        validate: onMount,\n        value: {\n          value: this.state.value,\n          fieldApi: this,\n          validationSource: 'field',\n        },\n        type: 'validate',\n      })\n      if (error) {\n        this.setMeta(\n          (prev) =>\n            ({\n              ...prev,\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              errorMap: { ...prev?.errorMap, onMount: error },\n              errorSourceMap: {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ...prev?.errorSourceMap,\n                onMount: 'field',\n              },\n            }) as never,\n        )\n      }\n    }\n\n    this.options.listeners?.onMount?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n\n    return cleanup\n  }\n\n  /**\n   * Updates the field instance with new options.\n   */\n  update = (\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnServer,\n      TParentSubmitMeta\n    >,\n  ) => {\n    this.options = opts as never\n\n    const nameHasChanged = this.name !== opts.name\n    this.name = opts.name\n\n    // Default Value\n    if ((this.state.value as unknown) === undefined) {\n      const formDefault = getBy(opts.form.options.defaultValues, opts.name)\n\n      const defaultValue = (opts.defaultValue as unknown) ?? formDefault\n\n      // The name is dynamic in array fields. It changes when the user performs operations like removing or reordering.\n      // In this case, we don't want to force a default value if the store managed to find an existing value.\n      if (nameHasChanged) {\n        this.setValue((val) => (val as unknown) || defaultValue, {\n          dontUpdateMeta: true,\n        })\n      } else if (defaultValue !== undefined) {\n        this.setValue(defaultValue as never, {\n          dontUpdateMeta: true,\n        })\n      }\n    }\n\n    // Default Meta\n    if (this.form.getFieldMeta(this.name) === undefined) {\n      this.setMeta(this.state.meta)\n    }\n  }\n\n  /**\n   * Gets the current field value.\n   * @deprecated Use `field.state.value` instead.\n   */\n  getValue = (): TData => {\n    return this.form.getFieldValue(this.name) as TData\n  }\n\n  /**\n   * Sets the field value and run the `change` validator.\n   */\n  setValue = (updater: Updater<TData>, options?: UpdateMetaOptions) => {\n    this.form.setFieldValue(this.name, updater as never, options)\n\n    this.triggerOnChangeListener()\n\n    this.validate('change')\n  }\n\n  getMeta = () => this.store.state.meta\n\n  /**\n   * Sets the field metadata.\n   */\n  setMeta = (\n    updater: Updater<\n      FieldMetaBase<\n        TParentData,\n        TName,\n        TData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync,\n        TFormOnMount,\n        TFormOnChange,\n        TFormOnChangeAsync,\n        TFormOnBlur,\n        TFormOnBlurAsync,\n        TFormOnSubmit,\n        TFormOnSubmitAsync\n      >\n    >,\n  ) => this.form.setFieldMeta(this.name, updater)\n\n  /**\n   * Gets the field information object.\n   */\n  getInfo = () => this.form.getFieldInfo(this.name)\n\n  /**\n   * Pushes a new value to the field.\n   */\n  pushValue = (\n    value: TData extends any[] ? TData[number] : never,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.form.pushFieldValue(this.name, value as any, opts)\n\n    this.triggerOnChangeListener()\n  }\n\n  /**\n   * Inserts a value at the specified index, shifting the subsequent values to the right.\n   */\n  insertValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.form.insertFieldValue(this.name, index, value as any, opts)\n\n    this.triggerOnChangeListener()\n  }\n\n  /**\n   * Replaces a value at the specified index.\n   */\n  replaceValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.form.replaceFieldValue(this.name, index, value as any, opts)\n\n    this.triggerOnChangeListener()\n  }\n\n  /**\n   * Removes a value at the specified index.\n   */\n  removeValue = (index: number, opts?: UpdateMetaOptions) => {\n    this.form.removeFieldValue(this.name, index, opts)\n\n    this.triggerOnChangeListener()\n  }\n\n  /**\n   * Swaps the values at the specified indices.\n   */\n  swapValues = (aIndex: number, bIndex: number, opts?: UpdateMetaOptions) => {\n    this.form.swapFieldValues(this.name, aIndex, bIndex, opts)\n\n    this.triggerOnChangeListener()\n  }\n\n  /**\n   * Moves the value at the first specified index to the second specified index.\n   */\n  moveValue = (aIndex: number, bIndex: number, opts?: UpdateMetaOptions) => {\n    this.form.moveFieldValues(this.name, aIndex, bIndex, opts)\n\n    this.triggerOnChangeListener()\n  }\n\n  /**\n   * Clear all values from the array.\n   */\n  clearValues = (opts?: UpdateMetaOptions) => {\n    this.form.clearFieldValues(this.name, opts)\n\n    this.triggerOnChangeListener()\n  }\n\n  /**\n   * @private\n   */\n  getLinkedFields = (cause: ValidationCause) => {\n    const fields = Object.values(this.form.fieldInfo) as FieldInfo<any>[]\n\n    const linkedFields: AnyFieldApi[] = []\n    for (const field of fields) {\n      if (!field.instance) continue\n      const { onChangeListenTo, onBlurListenTo } =\n        field.instance.options.validators || {}\n      if (cause === 'change' && onChangeListenTo?.includes(this.name)) {\n        linkedFields.push(field.instance)\n      }\n      if (cause === 'blur' && onBlurListenTo?.includes(this.name as string)) {\n        linkedFields.push(field.instance)\n      }\n    }\n\n    return linkedFields\n  }\n\n  /**\n   * @private\n   */\n  validateSync = (\n    cause: ValidationCause,\n    errorFromForm: ValidationErrorMap,\n  ) => {\n    const validates = getSyncValidatorArray(cause, this.options)\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getSyncValidatorArray(cause, field.options)\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        SyncValidator<any> & {\n          field: AnyFieldApi\n        }\n      >,\n    )\n\n    // Needs type cast as eslint errantly believes this is always falsy\n    let hasErrored = false as boolean\n\n    batch(() => {\n      const validateFieldFn = (\n        field: AnyFieldApi,\n        validateObj: SyncValidator<any>,\n      ) => {\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n\n        const fieldLevelError = validateObj.validate\n          ? normalizeError(\n              field.runValidator({\n                validate: validateObj.validate,\n                value: {\n                  value: field.store.state.value,\n                  validationSource: 'field',\n                  fieldApi: field,\n                },\n                type: 'validate',\n              }),\n            )\n          : undefined\n\n        const formLevelError = errorFromForm[errorMapKey]\n\n        const { newErrorValue, newSource } =\n          determineFieldLevelErrorSourceAndValue({\n            formLevelError,\n            fieldLevelError,\n          })\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (field.state.meta.errorMap?.[errorMapKey] !== newErrorValue) {\n          field.setMeta((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: newErrorValue,\n            },\n            errorSourceMap: {\n              ...prev.errorSourceMap,\n              [errorMapKey]: newSource,\n            },\n          }))\n        }\n        if (newErrorValue) {\n          hasErrored = true\n        }\n      }\n\n      for (const validateObj of validates) {\n        validateFieldFn(this, validateObj)\n      }\n      for (const fieldValitateObj of linkedFieldValidates) {\n        if (!fieldValitateObj.validate) continue\n        validateFieldFn(fieldValitateObj.field, fieldValitateObj)\n      }\n    })\n\n    /**\n     *  when we have an error for onSubmit in the state, we want\n     *  to clear the error as soon as the user enters a valid value in the field\n     */\n    const submitErrKey = getErrorMapKey('submit')\n\n    if (\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      this.state.meta.errorMap?.[submitErrKey] &&\n      cause !== 'submit' &&\n      !hasErrored\n    ) {\n      this.setMeta((prev) => ({\n        ...prev,\n        errorMap: {\n          ...prev.errorMap,\n          [submitErrKey]: undefined,\n        },\n        errorSourceMap: {\n          ...prev.errorSourceMap,\n          [submitErrKey]: undefined,\n        },\n      }))\n    }\n\n    return { hasErrored }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n    formValidationResultPromise: Promise<\n      FieldErrorMapFromValidator<\n        TParentData,\n        TName,\n        TData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync\n      >\n    >,\n  ) => {\n    const validates = getAsyncValidatorArray(cause, this.options)\n\n    // Get the field-specific error messages that are coming from the form's validator\n    const asyncFormValidationResults = await formValidationResultPromise\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getAsyncValidatorArray(cause, field.options)\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        AsyncValidator<any> & {\n          field: AnyFieldApi\n        }\n      >,\n    )\n\n    if (!this.state.meta.isValidating) {\n      this.setMeta((prev) => ({ ...prev, isValidating: true }))\n    }\n\n    for (const linkedField of linkedFields) {\n      linkedField.setMeta((prev) => ({ ...prev, isValidating: true }))\n    }\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const validatesPromises: Promise<ValidationError | undefined>[] = []\n    const linkedPromises: Promise<ValidationError | undefined>[] = []\n\n    const validateFieldAsyncFn = (\n      field: AnyFieldApi,\n      validateObj: AsyncValidator<any>,\n      promises: Promise<ValidationError | undefined>[],\n    ) => {\n      const errorMapKey = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = field.getInfo().validationMetaMap[errorMapKey]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.getInfo().validationMetaMap[errorMapKey] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationError | undefined>(async (resolve) => {\n          let rawError!: ValidationError | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              if (this.timeoutIds.validations[validateObj.cause]) {\n                clearTimeout(this.timeoutIds.validations[validateObj.cause]!)\n              }\n\n              this.timeoutIds.validations[validateObj.cause] = setTimeout(\n                async () => {\n                  if (controller.signal.aborted) return rawResolve(undefined)\n                  try {\n                    rawResolve(\n                      await this.runValidator({\n                        validate: validateObj.validate,\n                        value: {\n                          value: field.store.state.value,\n                          fieldApi: field,\n                          signal: controller.signal,\n                          validationSource: 'field',\n                        },\n                        type: 'validateAsync',\n                      }),\n                    )\n                  } catch (e) {\n                    rawReject(e)\n                  }\n                },\n                validateObj.debounceMs,\n              )\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          if (controller.signal.aborted) return resolve(undefined)\n\n          const fieldLevelError = normalizeError(rawError)\n          const formLevelError =\n            asyncFormValidationResults[this.name]?.[errorMapKey]\n\n          const { newErrorValue, newSource } =\n            determineFieldLevelErrorSourceAndValue({\n              formLevelError,\n              fieldLevelError,\n            })\n\n          field.setMeta((prev) => {\n            return {\n              ...prev,\n              errorMap: {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ...prev?.errorMap,\n                [errorMapKey]: newErrorValue,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: newSource,\n              },\n            }\n          })\n\n          resolve(newErrorValue)\n        }),\n      )\n    }\n\n    // TODO: Dedupe this logic to reduce bundle size\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      validateFieldAsyncFn(this, validateObj, validatesPromises)\n    }\n    for (const fieldValitateObj of linkedFieldValidates) {\n      if (!fieldValitateObj.validate) continue\n      validateFieldAsyncFn(\n        fieldValitateObj.field,\n        fieldValitateObj,\n        linkedPromises,\n      )\n    }\n\n    let results: ValidationError[] = []\n    if (validatesPromises.length || linkedPromises.length) {\n      results = await Promise.all(validatesPromises)\n      await Promise.all(linkedPromises)\n    }\n\n    this.setMeta((prev) => ({ ...prev, isValidating: false }))\n\n    for (const linkedField of linkedFields) {\n      linkedField.setMeta((prev) => ({ ...prev, isValidating: false }))\n    }\n\n    return results.filter(Boolean)\n  }\n\n  /**\n   * Validates the field value.\n   */\n  validate = (\n    cause: ValidationCause,\n    opts?: { skipFormValidation?: boolean },\n  ): ValidationError[] | Promise<ValidationError[]> => {\n    // If the field is pristine, do not validate\n    if (!this.state.meta.isTouched) return []\n\n    // Attempt to sync validate first\n    const { fieldsErrorMap } = opts?.skipFormValidation\n      ? { fieldsErrorMap: {} as never }\n      : this.form.validateSync(cause)\n    const { hasErrored } = this.validateSync(\n      cause,\n      fieldsErrorMap[this.name] ?? {},\n    )\n\n    if (hasErrored && !this.options.asyncAlways) {\n      this.getInfo().validationMetaMap[\n        getErrorMapKey(cause)\n      ]?.lastAbortController.abort()\n      return this.state.meta.errors\n    }\n\n    // No error? Attempt async validation\n    const formValidationResultPromise = opts?.skipFormValidation\n      ? Promise.resolve({})\n      : this.form.validateAsync(cause)\n    return this.validateAsync(cause, formValidationResultPromise)\n  }\n\n  /**\n   * Handles the change event.\n   */\n  handleChange = (updater: Updater<TData>) => {\n    this.setValue(updater)\n  }\n\n  /**\n   * Handles the blur event.\n   */\n  handleBlur = () => {\n    const prevTouched = this.state.meta.isTouched\n    if (!prevTouched) {\n      this.setMeta((prev) => ({ ...prev, isTouched: true }))\n    }\n    if (!this.state.meta.isBlurred) {\n      this.setMeta((prev) => ({ ...prev, isBlurred: true }))\n    }\n    this.validate('blur')\n\n    this.triggerOnBlurListener()\n  }\n\n  /**\n   * Updates the field's errorMap\n   */\n  setErrorMap(\n    errorMap: ValidationErrorMap<\n      UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>,\n      UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>\n    >,\n  ) {\n    this.setMeta((prev) => ({\n      ...prev,\n      errorMap: {\n        ...prev.errorMap,\n        ...errorMap,\n      },\n    }))\n  }\n\n  /**\n   * Parses the field's value with the given schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse this field's value with.\n   */\n  parseValueWithSchema = (schema: StandardSchemaV1<TData, unknown>) => {\n    return standardSchemaValidators.validate(\n      { value: this.state.value, validationSource: 'field' },\n      schema,\n    )\n  }\n\n  /**\n   * Parses the field's value with the given schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse this field's value with.\n   */\n  parseValueWithSchemaAsync = (schema: StandardSchemaV1<TData, unknown>) => {\n    return standardSchemaValidators.validateAsync(\n      { value: this.state.value, validationSource: 'field' },\n      schema,\n    )\n  }\n\n  private triggerOnBlurListener() {\n    const formDebounceMs = this.form.options.listeners?.onBlurDebounceMs\n    if (formDebounceMs && formDebounceMs > 0) {\n      if (this.timeoutIds.formListeners.blur) {\n        clearTimeout(this.timeoutIds.formListeners.blur)\n      }\n\n      this.timeoutIds.formListeners.blur = setTimeout(() => {\n        this.form.options.listeners?.onBlur?.({\n          formApi: this.form,\n          fieldApi: this,\n        })\n      }, formDebounceMs)\n    } else {\n      this.form.options.listeners?.onBlur?.({\n        formApi: this.form,\n        fieldApi: this,\n      })\n    }\n\n    const fieldDebounceMs = this.options.listeners?.onBlurDebounceMs\n    if (fieldDebounceMs && fieldDebounceMs > 0) {\n      if (this.timeoutIds.listeners.blur) {\n        clearTimeout(this.timeoutIds.listeners.blur)\n      }\n\n      this.timeoutIds.listeners.blur = setTimeout(() => {\n        this.options.listeners?.onBlur?.({\n          value: this.state.value,\n          fieldApi: this,\n        })\n      }, fieldDebounceMs)\n    } else {\n      this.options.listeners?.onBlur?.({\n        value: this.state.value,\n        fieldApi: this,\n      })\n    }\n  }\n\n  private triggerOnChangeListener() {\n    const formDebounceMs = this.form.options.listeners?.onChangeDebounceMs\n    if (formDebounceMs && formDebounceMs > 0) {\n      if (this.timeoutIds.formListeners.change) {\n        clearTimeout(this.timeoutIds.formListeners.change)\n      }\n\n      this.timeoutIds.formListeners.change = setTimeout(() => {\n        this.form.options.listeners?.onChange?.({\n          formApi: this.form,\n          fieldApi: this,\n        })\n      }, formDebounceMs)\n    } else {\n      this.form.options.listeners?.onChange?.({\n        formApi: this.form,\n        fieldApi: this,\n      })\n    }\n\n    const fieldDebounceMs = this.options.listeners?.onChangeDebounceMs\n    if (fieldDebounceMs && fieldDebounceMs > 0) {\n      if (this.timeoutIds.listeners.change) {\n        clearTimeout(this.timeoutIds.listeners.change)\n      }\n\n      this.timeoutIds.listeners.change = setTimeout(() => {\n        this.options.listeners?.onChange?.({\n          value: this.state.value,\n          fieldApi: this,\n        })\n      }, fieldDebounceMs)\n    } else {\n      this.options.listeners?.onChange?.({\n        value: this.state.value,\n        fieldApi: this,\n      })\n    }\n  }\n}\n\nfunction normalizeError(rawError?: ValidationError) {\n  if (rawError) {\n    return rawError\n  }\n\n  return undefined\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n", "import type { FormApi } from './FormApi'\n\nfunction isValidKey(key: string | number | symbol): boolean {\n  const dangerousProps = ['__proto__', 'constructor', 'prototype']\n  return !dangerousProps.includes(String(key))\n}\n\n/**\n * @private\n */\nexport function mutateMergeDeep(\n  target: object | null | undefined,\n  source: object | null | undefined,\n): object {\n  // Early return if either is not an object\n  if (target === null || target === undefined || typeof target !== 'object')\n    return {} as object\n  if (source === null || source === undefined || typeof source !== 'object')\n    return target\n\n  const targetKeys = Object.keys(target)\n  const sourceKeys = Object.keys(source)\n  const keySet = new Set([...targetKeys, ...sourceKeys])\n\n  for (const key of keySet) {\n    if (!isValidKey(key)) continue\n\n    const targetKey = key as keyof typeof target\n    const sourceKey = key as keyof typeof source\n\n    if (!Object.hasOwn(source, sourceKey)) continue\n\n    const sourceValue = source[sourceKey] as unknown\n    const targetValue = target[targetKey] as unknown\n\n    // Handle arrays\n    if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {\n      Object.defineProperty(target, key, {\n        value: [...sourceValue],\n        enumerable: true,\n        writable: true,\n        configurable: true,\n      })\n      continue\n    }\n\n    // Handle nested objects (type assertion to satisfy ESLint)\n    const isTargetObj = typeof targetValue === 'object' && targetValue !== null\n    const isSourceObj = typeof sourceValue === 'object' && sourceValue !== null\n    const areObjects =\n      isTargetObj &&\n      isSourceObj &&\n      !Array.isArray(targetValue) &&\n      !Array.isArray(sourceValue)\n\n    if (areObjects) {\n      mutateMergeDeep(targetValue as object, sourceValue as object)\n      continue\n    }\n\n    // Handle all other cases\n    Object.defineProperty(target, key, {\n      value: sourceValue,\n      enumerable: true,\n      writable: true,\n      configurable: true,\n    })\n  }\n\n  return target\n}\n\nexport function mergeForm<TFormData>(\n  baseForm: FormApi<\n    NoInfer<TFormData>,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >,\n  state: Partial<\n    FormApi<TFormData, any, any, any, any, any, any, any, any, any>['state']\n  >,\n) {\n  mutateMergeDeep(baseForm.state, state)\n  return baseForm\n}\n", "import type { FormOptions } from './FormApi'\n\nexport function formOptions<\n  T extends Partial<\n    FormOptions<any, any, any, any, any, any, any, any, any, any>\n  >,\n>(defaultOpts: T) {\n  return defaultOpts\n}\n", "import { useEffect, useLayoutEffect } from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect\n", "import React, { useMemo, useState } from 'react'\nimport { useStore } from '@tanstack/react-store'\nimport { FieldApi, functionalUpdate } from '@tanstack/form-core'\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect'\nimport type {\n  DeepKeys,\n  DeepValue,\n  FieldAsyncValidateOrFn,\n  FieldValidateOrFn,\n  FormAsyncValidateOrFn,\n  FormValidateOrFn,\n} from '@tanstack/form-core'\nimport type { FunctionComponent, ReactNode } from 'react'\nimport type { UseFieldOptions, UseFieldOptionsBound } from './types'\n\ninterface ReactFieldApi<\n  TParentData,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TPatentSubmitMeta,\n> {\n  /**\n   * A pre-bound and type-safe sub-field component using this field as a root.\n   */\n  Field: FieldComponent<\n    TParentData,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnServer,\n    TPatentSubmitMeta\n  >\n}\n\n/**\n * A type representing a hook for using a field in a form with the given form data type.\n *\n * A function that takes an optional object with a `name` property and field options, and returns a `FieldApi` instance for the specified field.\n */\nexport type UseField<\n  TParentData,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TPatentSubmitMeta,\n> = <\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n>(\n  opts: UseFieldOptionsBound<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync\n  >,\n) => FieldApi<\n  TParentData,\n  TName,\n  TData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TFormOnMount,\n  TFormOnChange,\n  TFormOnChangeAsync,\n  TFormOnBlur,\n  TFormOnBlurAsync,\n  TFormOnSubmit,\n  TFormOnSubmitAsync,\n  TFormOnServer,\n  TPatentSubmitMeta\n>\n\n/**\n * A hook for managing a field in a form.\n * @param opts An object with field options.\n *\n * @returns The `FieldApi` instance for the specified field.\n */\nexport function useField<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TPatentSubmitMeta,\n>(\n  opts: UseFieldOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnServer,\n    TPatentSubmitMeta\n  >,\n) {\n  const [fieldApi] = useState(() => {\n    const api = new FieldApi({\n      ...opts,\n      form: opts.form,\n      name: opts.name,\n    })\n\n    const extendedApi: typeof api &\n      ReactFieldApi<\n        TParentData,\n        TFormOnMount,\n        TFormOnChange,\n        TFormOnChangeAsync,\n        TFormOnBlur,\n        TFormOnBlurAsync,\n        TFormOnSubmit,\n        TFormOnSubmitAsync,\n        TFormOnServer,\n        TPatentSubmitMeta\n      > = api as never\n\n    extendedApi.Field = Field as never\n\n    return extendedApi\n  })\n\n  useIsomorphicLayoutEffect(fieldApi.mount, [fieldApi])\n\n  /**\n   * fieldApi.update should not have any side effects. Think of it like a `useRef`\n   * that we need to keep updated every render with the most up-to-date information.\n   */\n  useIsomorphicLayoutEffect(() => {\n    fieldApi.update(opts)\n  })\n\n  useStore(\n    fieldApi.store,\n    opts.mode === 'array'\n      ? (state) => {\n          return [\n            state.meta,\n            Object.keys((state.value as unknown) ?? []).length,\n          ]\n        }\n      : undefined,\n  )\n\n  return fieldApi\n}\n\n/**\n * @param children A render function that takes a field API instance and returns a React element.\n */\ninterface FieldComponentProps<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TPatentSubmitMeta,\n  ExtendedApi = {},\n> extends UseFieldOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnServer,\n    TPatentSubmitMeta\n  > {\n  children: (\n    fieldApi: FieldApi<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnServer,\n      TPatentSubmitMeta\n    > &\n      ExtendedApi,\n  ) => ReactNode\n}\n\ninterface FieldComponentBoundProps<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TPatentSubmitMeta,\n  ExtendedApi = {},\n> extends UseFieldOptionsBound<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync\n  > {\n  children: (\n    fieldApi: FieldApi<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnServer,\n      TPatentSubmitMeta\n    > &\n      ExtendedApi,\n  ) => ReactNode\n}\n\n/**\n * A type alias representing a field component for a specific form data type.\n */\nexport type FieldComponent<\n  in out TParentData,\n  in out TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChangeAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnBlurAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnSubmitAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  in out TPatentSubmitMeta,\n  in out ExtendedApi = {},\n> = <\n  const TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n>({\n  children,\n  ...fieldOptions\n}: FieldComponentBoundProps<\n  TParentData,\n  TName,\n  TData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TFormOnMount,\n  TFormOnChange,\n  TFormOnChangeAsync,\n  TFormOnBlur,\n  TFormOnBlurAsync,\n  TFormOnSubmit,\n  TFormOnSubmitAsync,\n  TFormOnServer,\n  TPatentSubmitMeta,\n  ExtendedApi\n>) => ReactNode\n\n/**\n * A function component that takes field options and a render function as children and returns a React component.\n *\n * The `Field` component uses the `useField` hook internally to manage the field instance.\n */\nexport const Field = (<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TPatentSubmitMeta,\n>({\n  children,\n  ...fieldOptions\n}: FieldComponentProps<\n  TParentData,\n  TName,\n  TData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TFormOnMount,\n  TFormOnChange,\n  TFormOnChangeAsync,\n  TFormOnBlur,\n  TFormOnBlurAsync,\n  TFormOnSubmit,\n  TFormOnSubmitAsync,\n  TFormOnServer,\n  TPatentSubmitMeta\n>): ReactNode => {\n  const fieldApi = useField(fieldOptions as any)\n\n  const jsxToDisplay = useMemo(\n    () => functionalUpdate(children, fieldApi as any),\n    /**\n     * The reason this exists is to fix an issue with the React Compiler.\n     * Namely, functionalUpdate is memoized where it checks for `fieldApi`, which is a static type.\n     * This means that when `state.value` changes, it does not trigger a re-render. The useMemo explicitly fixes this problem\n     */\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [children, fieldApi, fieldApi.state.value, fieldApi.state.meta],\n  )\n  return (<>{jsxToDisplay}</>) as never\n}) satisfies FunctionComponent<\n  FieldComponentProps<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n>\n", "import { FormApi, functionalUpdate } from '@tanstack/form-core'\nimport { useStore } from '@tanstack/react-store'\nimport { useState } from 'react'\nimport { Field } from './useField'\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect'\nimport type {\n  AnyFormApi,\n  AnyFormState,\n  FormAsyncValidateOrFn,\n  FormOptions,\n  FormState,\n  FormValidateOrFn,\n} from '@tanstack/form-core'\nimport type { PropsWithChildren, ReactNode } from 'react'\nimport type { FieldComponent } from './useField'\nimport type { NoInfer } from '@tanstack/react-store'\n\n/**\n * Fields that are added onto the `FormAPI` from `@tanstack/form-core` and returned from `useForm`\n */\nexport interface ReactFormApi<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TSubmitMeta,\n> {\n  /**\n   * A React component to render form fields. With this, you can render and manage individual form fields.\n   */\n  Field: FieldComponent<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnServer,\n    TSubmitMeta\n  >\n  /**\n   * A `Subscribe` function that allows you to listen and react to changes in the form's state. It's especially useful when you need to execute side effects or render specific components in response to state updates.\n   */\n  Subscribe: <\n    TSelected = NoInfer<\n      FormState<\n        TFormData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync,\n        TOnServer\n      >\n    >,\n  >(props: {\n    selector?: (\n      state: NoInfer<\n        FormState<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnServer\n        >\n      >,\n    ) => TSelected\n    children: ((state: NoInfer<TSelected>) => ReactNode) | ReactNode\n  }) => ReactNode\n}\n\n/**\n * An extended version of the `FormApi` class that includes React-specific functionalities from `ReactFormApi`\n */\nexport type ReactFormExtendedApi<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta,\n> = FormApi<\n  TFormData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnServer,\n  TSubmitMeta\n> &\n  ReactFormApi<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnServer,\n    TSubmitMeta\n  >\n\nfunction LocalSubscribe({\n  form,\n  selector,\n  children,\n}: PropsWithChildren<{\n  form: AnyFormApi\n  selector: (state: AnyFormState) => AnyFormState\n}>) {\n  const data = useStore(form.store, selector)\n\n  return functionalUpdate(children, data)\n}\n\n/**\n * A custom React Hook that returns an extended instance of the `FormApi` class.\n *\n * This API encapsulates all the necessary functionalities related to the form. It allows you to manage form state, handle submissions, and interact with form fields\n */\nexport function useForm<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta,\n>(\n  opts?: FormOptions<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnServer,\n    TSubmitMeta\n  >,\n) {\n  const [formApi] = useState(() => {\n    const api = new FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer,\n      TSubmitMeta\n    >(opts)\n\n    const extendedApi: ReactFormExtendedApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer,\n      TSubmitMeta\n    > = api as never\n\n    extendedApi.Field = function APIField(props) {\n      return <Field {...props} form={api} />\n    }\n\n    extendedApi.Subscribe = function Subscribe(props: any) {\n      return (\n        <LocalSubscribe\n          form={api}\n          selector={props.selector}\n          children={props.children}\n        />\n      )\n    }\n\n    return extendedApi\n  })\n\n  useIsomorphicLayoutEffect(formApi.mount, [])\n\n  /**\n   * formApi.update should not have any side effects. Think of it like a `useRef`\n   * that we need to keep updated every render with the most up-to-date information.\n   */\n  useIsomorphicLayoutEffect(() => {\n    formApi.update(opts)\n  })\n\n  return formApi\n}\n", "import type {\n  AnyFormApi,\n  FormApi,\n  FormAsyncValidateOrFn,\n  FormTransform,\n  FormValidateOrFn,\n} from '@tanstack/form-core'\n\nexport function useTransform(\n  fn: (formBase: AnyFormApi) => AnyFormApi,\n  deps: unknown[],\n): FormTransform<any, any, any, any, any, any, any, any, any, any> {\n  return {\n    fn,\n    deps,\n  }\n}\n", "import { createContext, useContext, useMemo } from 'react'\nimport { useForm } from './useForm'\nimport type {\n  AnyFieldApi,\n  AnyFormApi,\n  FieldApi,\n  FormApi,\n  FormAsyncValidateOrFn,\n  FormOptions,\n  FormValidateOrFn,\n} from '@tanstack/form-core'\nimport type { ComponentType, Context, JSX, PropsWithChildren } from 'react'\nimport type { FieldComponent } from './useField'\nimport type { ReactFormExtendedApi } from './useForm'\n\n/**\n * TypeScript inferencing is weird.\n *\n * If you have:\n *\n * @example\n *\n * interface Args<T> {\n *     arg?: T\n * }\n *\n * function test<T>(arg?: Partial<Args<T>>): T {\n *     return 0 as any;\n * }\n *\n * const a = test({});\n *\n * Then `T` will default to `unknown`.\n *\n * However, if we change `test` to be:\n *\n * @example\n *\n * function test<T extends undefined>(arg?: Partial<Args<T>>): T;\n *\n * Then `T` becomes `undefined`.\n *\n * Here, we are checking if the passed type `T` extends `DefaultT` and **only**\n * `DefaultT`, as if that's the case we assume that inferencing has not occured.\n */\ntype UnwrapOrAny<T> = [unknown] extends [T] ? any : T\ntype UnwrapDefaultOrAny<DefaultT, T> = [DefaultT] extends [T]\n  ? [T] extends [DefaultT]\n    ? any\n    : T\n  : T\n\nexport function createFormHookContexts() {\n  // We should never hit the `null` case here\n  const fieldContext = createContext<AnyFieldApi>(null as never)\n\n  function useFieldContext<TData>() {\n    const field = useContext(fieldContext)\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!field) {\n      throw new Error(\n        '`fieldContext` only works when within a `fieldComponent` passed to `createFormHook`',\n      )\n    }\n\n    return field as FieldApi<\n      any,\n      string,\n      TData,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any\n    >\n  }\n\n  // We should never hit the `null` case here\n  const formContext = createContext<AnyFormApi>(null as never)\n\n  function useFormContext() {\n    const form = useContext(formContext)\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!form) {\n      throw new Error(\n        '`formContext` only works when within a `formComponent` passed to `createFormHook`',\n      )\n    }\n\n    return form as ReactFormExtendedApi<\n      // If you need access to the form data, you need to use `withForm` instead\n      Record<string, never>,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any\n    >\n  }\n\n  return { fieldContext, useFieldContext, useFormContext, formContext }\n}\n\ninterface CreateFormHookProps<\n  TFieldComponents extends Record<string, ComponentType<any>>,\n  TFormComponents extends Record<string, ComponentType<any>>,\n> {\n  fieldComponents: TFieldComponents\n  fieldContext: Context<AnyFieldApi>\n  formComponents: TFormComponents\n  formContext: Context<AnyFormApi>\n}\n\ntype AppFieldExtendedReactFormApi<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta,\n  TFieldComponents extends Record<string, ComponentType<any>>,\n  TFormComponents extends Record<string, ComponentType<any>>,\n> = ReactFormExtendedApi<\n  TFormData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnServer,\n  TSubmitMeta\n> &\n  NoInfer<TFormComponents> & {\n    AppField: FieldComponent<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer,\n      TSubmitMeta,\n      NoInfer<TFieldComponents>\n    >\n    AppForm: ComponentType<PropsWithChildren>\n  }\n\nexport interface WithFormProps<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta,\n  TFieldComponents extends Record<string, ComponentType<any>>,\n  TFormComponents extends Record<string, ComponentType<any>>,\n  TRenderProps extends object = Record<string, never>,\n> extends FormOptions<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnServer,\n    TSubmitMeta\n  > {\n  // Optional, but adds props to the `render` function outside of `form`\n  props?: TRenderProps\n  render: (\n    props: PropsWithChildren<\n      NoInfer<TRenderProps> & {\n        form: AppFieldExtendedReactFormApi<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnServer,\n          TSubmitMeta,\n          TFieldComponents,\n          TFormComponents\n        >\n      }\n    >,\n  ) => JSX.Element\n}\n\nexport function createFormHook<\n  const TComponents extends Record<string, ComponentType<any>>,\n  const TFormComponents extends Record<string, ComponentType<any>>,\n>({\n  fieldComponents,\n  fieldContext,\n  formContext,\n  formComponents,\n}: CreateFormHookProps<TComponents, TFormComponents>) {\n  function useAppForm<\n    TFormData,\n    TOnMount extends undefined | FormValidateOrFn<TFormData>,\n    TOnChange extends undefined | FormValidateOrFn<TFormData>,\n    TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n    TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n    TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n    TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n    TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n    TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n    TSubmitMeta,\n  >(\n    props: FormOptions<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ): AppFieldExtendedReactFormApi<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnServer,\n    TSubmitMeta,\n    TComponents,\n    TFormComponents\n  > {\n    const form = useForm(props)\n\n    const AppForm = useMemo(() => {\n      const AppForm = (({ children }) => {\n        return (\n          <formContext.Provider value={form}>{children}</formContext.Provider>\n        )\n      }) as ComponentType<PropsWithChildren>\n      return AppForm\n    }, [form])\n\n    const AppField = useMemo(() => {\n      const AppField = (({ children, ...props }) => {\n        return (\n          <form.Field {...props}>\n            {(field) => (\n              // eslint-disable-next-line @eslint-react/no-context-provider\n              <fieldContext.Provider value={field}>\n                {children(Object.assign(field, fieldComponents))}\n              </fieldContext.Provider>\n            )}\n          </form.Field>\n        )\n      }) as FieldComponent<\n        TFormData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync,\n        TOnServer,\n        TSubmitMeta,\n        TComponents\n      >\n      return AppField\n    }, [form])\n\n    const extendedForm = useMemo(() => {\n      return Object.assign(form, {\n        AppField,\n        AppForm,\n        ...formComponents,\n      })\n    }, [form, AppField, AppForm])\n\n    return extendedForm\n  }\n\n  function withForm<\n    TFormData,\n    TOnMount extends undefined | FormValidateOrFn<TFormData>,\n    TOnChange extends undefined | FormValidateOrFn<TFormData>,\n    TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n    TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n    TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n    TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n    TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n    TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n    TSubmitMeta,\n    TRenderProps extends object = {},\n  >({\n    render,\n    props,\n  }: WithFormProps<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnServer,\n    TSubmitMeta,\n    TComponents,\n    TFormComponents,\n    TRenderProps\n  >): WithFormProps<\n    UnwrapOrAny<TFormData>,\n    UnwrapDefaultOrAny<undefined | FormValidateOrFn<TFormData>, TOnMount>,\n    UnwrapDefaultOrAny<undefined | FormValidateOrFn<TFormData>, TOnChange>,\n    UnwrapDefaultOrAny<undefined | FormValidateOrFn<TFormData>, TOnChangeAsync>,\n    UnwrapDefaultOrAny<undefined | FormValidateOrFn<TFormData>, TOnBlur>,\n    UnwrapDefaultOrAny<undefined | FormValidateOrFn<TFormData>, TOnBlurAsync>,\n    UnwrapDefaultOrAny<undefined | FormValidateOrFn<TFormData>, TOnSubmit>,\n    UnwrapDefaultOrAny<undefined | FormValidateOrFn<TFormData>, TOnSubmitAsync>,\n    UnwrapDefaultOrAny<undefined | FormValidateOrFn<TFormData>, TOnServer>,\n    UnwrapOrAny<TSubmitMeta>,\n    UnwrapOrAny<TComponents>,\n    UnwrapOrAny<TFormComponents>,\n    UnwrapOrAny<TRenderProps>\n  >['render'] {\n    return (innerProps) => render({ ...props, ...innerProps })\n  }\n\n  return {\n    useAppForm,\n    withForm,\n  }\n}\n"],
  "mappings": "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",
  "names": ["_a", "opts", "_c", "_b", "opts", "getErrorMapKey", "normalizeError", "_a", "_b", "AppForm", "AppField", "props"]
}
