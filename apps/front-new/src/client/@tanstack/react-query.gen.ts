// This file is auto-generated by @hey-api/openapi-ts

import {
  getAuthLoginByToken,
  getAuthSearchToken,
  getAutocompleteCompany,
  getAutocompleteLocation,
  getAutocompletePosition,
  getCompanyPosition,
  getSubmissions,
  getSubmissionsMe,
  type Options,
  patchSubmissions,
  postAuthLogin,
  postCompanyPosition,
  postSubmissions,
} from '../sdk.gen'
import {
  type DefaultError,
  queryOptions,
  type UseMutationOptions,
} from '@tanstack/react-query'
import type {
  GetAuthLoginByTokenData,
  GetAuthSearchTokenData,
  GetAutocompleteCompanyData,
  GetAutocompleteLocationData,
  GetAutocompletePositionData,
  GetCompanyPositionData,
  GetSubmissionsData,
  GetSubmissionsMeData,
  PatchSubmissionsData,
  PostAuthLoginData,
  PostCompanyPositionData,
  PostCompanyPositionError,
  PostCompanyPositionResponse,
  PostSubmissionsData,
} from '../types.gen'
import { client as _heyApiClient } from '../client.gen'

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string
    _infinite?: boolean
  },
]

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl,
  } as QueryKey<TOptions>[0]
  if (infinite) {
    params._infinite = infinite
  }
  if (options?.body) {
    params.body = options.body
  }
  if (options?.headers) {
    params.headers = options.headers
  }
  if (options?.path) {
    params.path = options.path
  }
  if (options?.query) {
    params.query = options.query
  }
  return [params]
}

export const getAuthSearchTokenQueryKey = (
  options?: Options<GetAuthSearchTokenData>,
) => createQueryKey('getAuthSearchToken', options)

/**
 * Get a tenant token for searching, filtering, and sorting (expires in 1 day)
 */
export const getAuthSearchTokenOptions = (
  options?: Options<GetAuthSearchTokenData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAuthSearchToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getAuthSearchTokenQueryKey(options),
  })
}

export const postAuthLoginQueryKey = (options: Options<PostAuthLoginData>) =>
  createQueryKey('postAuthLogin', options)

/**
 * Request a magic link for authentication
 */
export const postAuthLoginOptions = (options: Options<PostAuthLoginData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await postAuthLogin({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: postAuthLoginQueryKey(options),
  })
}

/**
 * Request a magic link for authentication
 */
export const postAuthLoginMutation = (
  options?: Partial<Options<PostAuthLoginData>>,
): UseMutationOptions<unknown, DefaultError, Options<PostAuthLoginData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<PostAuthLoginData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await postAuthLogin({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getAuthLoginByTokenQueryKey = (
  options: Options<GetAuthLoginByTokenData>,
) => createQueryKey('getAuthLoginByToken', options)

/**
 * Verify magic link token and authenticate user
 */
export const getAuthLoginByTokenOptions = (
  options: Options<GetAuthLoginByTokenData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAuthLoginByToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getAuthLoginByTokenQueryKey(options),
  })
}

export const getAutocompleteCompanyQueryKey = (
  options: Options<GetAutocompleteCompanyData>,
) => createQueryKey('getAutocompleteCompany', options)

/**
 * Search for companies by name with fuzzy matching
 */
export const getAutocompleteCompanyOptions = (
  options: Options<GetAutocompleteCompanyData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAutocompleteCompany({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getAutocompleteCompanyQueryKey(options),
  })
}

export const getAutocompletePositionQueryKey = (
  options: Options<GetAutocompletePositionData>,
) => createQueryKey('getAutocompletePosition', options)

/**
 * Search for positions within a specific company
 */
export const getAutocompletePositionOptions = (
  options: Options<GetAutocompletePositionData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAutocompletePosition({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getAutocompletePositionQueryKey(options),
  })
}

export const getAutocompleteLocationQueryKey = (
  options: Options<GetAutocompleteLocationData>,
) => createQueryKey('getAutocompleteLocation', options)

/**
 * Search for locations with fuzzy matching across city, state, and state code
 */
export const getAutocompleteLocationOptions = (
  options: Options<GetAutocompleteLocationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAutocompleteLocation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getAutocompleteLocationQueryKey(options),
  })
}

export const getCompanyPositionQueryKey = (
  options?: Options<GetCompanyPositionData>,
) => createQueryKey('getCompanyPosition', options)

/**
 * Retrieve companies and positions owned by the authenticated user
 */
export const getCompanyPositionOptions = (
  options?: Options<GetCompanyPositionData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCompanyPosition({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getCompanyPositionQueryKey(options),
  })
}

export const postCompanyPositionQueryKey = (
  options: Options<PostCompanyPositionData>,
) => createQueryKey('postCompanyPosition', options)

/**
 * Create a new company and position pair
 */
export const postCompanyPositionOptions = (
  options: Options<PostCompanyPositionData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await postCompanyPosition({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: postCompanyPositionQueryKey(options),
  })
}

/**
 * Create a new company and position pair
 */
export const postCompanyPositionMutation = (
  options?: Partial<Options<PostCompanyPositionData>>,
): UseMutationOptions<
  PostCompanyPositionResponse,
  PostCompanyPositionError,
  Options<PostCompanyPositionData>
> => {
  const mutationOptions: UseMutationOptions<
    PostCompanyPositionResponse,
    PostCompanyPositionError,
    Options<PostCompanyPositionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await postCompanyPosition({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getSubmissionsQueryKey = (options?: Options<GetSubmissionsData>) =>
  createQueryKey('getSubmissions', options)

/**
 * Retrieve co-op submission records with pagination and filtering
 */
export const getSubmissionsOptions = (
  options?: Options<GetSubmissionsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSubmissions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getSubmissionsQueryKey(options),
  })
}

/**
 * Update an existing co-op submission
 */
export const patchSubmissionsMutation = (
  options?: Partial<Options<PatchSubmissionsData>>,
): UseMutationOptions<unknown, DefaultError, Options<PatchSubmissionsData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<PatchSubmissionsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await patchSubmissions({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const postSubmissionsQueryKey = (
  options?: Options<PostSubmissionsData>,
) => createQueryKey('postSubmissions', options)

/**
 * Create new co-op submission(s)
 */
export const postSubmissionsOptions = (
  options?: Options<PostSubmissionsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await postSubmissions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: postSubmissionsQueryKey(options),
  })
}

/**
 * Create new co-op submission(s)
 */
export const postSubmissionsMutation = (
  options?: Partial<Options<PostSubmissionsData>>,
): UseMutationOptions<unknown, DefaultError, Options<PostSubmissionsData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<PostSubmissionsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await postSubmissions({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getSubmissionsMeQueryKey = (
  options?: Options<GetSubmissionsMeData>,
) => createQueryKey('getSubmissionsMe', options)

/**
 * Retrieve all co-op submissions owned by the authenticated user
 */
export const getSubmissionsMeOptions = (
  options?: Options<GetSubmissionsMeData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSubmissionsMe({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getSubmissionsMeQueryKey(options),
  })
}
